// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Common/ComDefine.proto

#ifndef PROTOBUF_Common_2fComDefine_2eproto__INCLUDED
#define PROTOBUF_Common_2fComDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)

namespace ProtoBuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Common_2fComDefine_2eproto();
void protobuf_AssignDesc_Common_2fComDefine_2eproto();
void protobuf_ShutdownFile_Common_2fComDefine_2eproto();


enum PROTOCOL_VERSION_UPPER {
  PROTOCOL_VERSION_CURRENT = 1
};
bool PROTOCOL_VERSION_UPPER_IsValid(int value);
const PROTOCOL_VERSION_UPPER PROTOCOL_VERSION_UPPER_MIN = PROTOCOL_VERSION_CURRENT;
const PROTOCOL_VERSION_UPPER PROTOCOL_VERSION_UPPER_MAX = PROTOCOL_VERSION_CURRENT;
const int PROTOCOL_VERSION_UPPER_ARRAYSIZE = PROTOCOL_VERSION_UPPER_MAX + 1;

const ::google::protobuf::EnumDescriptor* PROTOCOL_VERSION_UPPER_descriptor();
inline const ::std::string& PROTOCOL_VERSION_UPPER_Name(PROTOCOL_VERSION_UPPER value) {
  return ::google::protobuf::internal::NameOfEnum(
    PROTOCOL_VERSION_UPPER_descriptor(), value);
}
inline bool PROTOCOL_VERSION_UPPER_Parse(
    const ::std::string& name, PROTOCOL_VERSION_UPPER* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PROTOCOL_VERSION_UPPER>(
    PROTOCOL_VERSION_UPPER_descriptor(), name, value);
}
enum PROTOCOL_VERSION_LOWER {
  PROTOCOL_VERSION_LOWER_LIMIT = 1
};
bool PROTOCOL_VERSION_LOWER_IsValid(int value);
const PROTOCOL_VERSION_LOWER PROTOCOL_VERSION_LOWER_MIN = PROTOCOL_VERSION_LOWER_LIMIT;
const PROTOCOL_VERSION_LOWER PROTOCOL_VERSION_LOWER_MAX = PROTOCOL_VERSION_LOWER_LIMIT;
const int PROTOCOL_VERSION_LOWER_ARRAYSIZE = PROTOCOL_VERSION_LOWER_MAX + 1;

const ::google::protobuf::EnumDescriptor* PROTOCOL_VERSION_LOWER_descriptor();
inline const ::std::string& PROTOCOL_VERSION_LOWER_Name(PROTOCOL_VERSION_LOWER value) {
  return ::google::protobuf::internal::NameOfEnum(
    PROTOCOL_VERSION_LOWER_descriptor(), value);
}
inline bool PROTOCOL_VERSION_LOWER_Parse(
    const ::std::string& name, PROTOCOL_VERSION_LOWER* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PROTOCOL_VERSION_LOWER>(
    PROTOCOL_VERSION_LOWER_descriptor(), name, value);
}
enum PingConfig {
  CLIENT_PING_INTERVAL = 9,
  SERVER_PING_INTERVAL = 9
};
bool PingConfig_IsValid(int value);
const PingConfig PingConfig_MIN = CLIENT_PING_INTERVAL;
const PingConfig PingConfig_MAX = CLIENT_PING_INTERVAL;
const int PingConfig_ARRAYSIZE = PingConfig_MAX + 1;

const ::google::protobuf::EnumDescriptor* PingConfig_descriptor();
inline const ::std::string& PingConfig_Name(PingConfig value) {
  return ::google::protobuf::internal::NameOfEnum(
    PingConfig_descriptor(), value);
}
inline bool PingConfig_Parse(
    const ::std::string& name, PingConfig* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PingConfig>(
    PingConfig_descriptor(), name, value);
}
enum ECharacterSex {
  ECHARACTER_SEX_MAN = 1,
  ECHARACTER_SEX_FEMAL = 2
};
bool ECharacterSex_IsValid(int value);
const ECharacterSex ECharacterSex_MIN = ECHARACTER_SEX_MAN;
const ECharacterSex ECharacterSex_MAX = ECHARACTER_SEX_FEMAL;
const int ECharacterSex_ARRAYSIZE = ECharacterSex_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECharacterSex_descriptor();
inline const ::std::string& ECharacterSex_Name(ECharacterSex value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECharacterSex_descriptor(), value);
}
inline bool ECharacterSex_Parse(
    const ::std::string& name, ECharacterSex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECharacterSex>(
    ECharacterSex_descriptor(), name, value);
}
enum ERace {
  ERace_Human = 1,
  ERace_Fairy = 2
};
bool ERace_IsValid(int value);
const ERace ERace_MIN = ERace_Human;
const ERace ERace_MAX = ERace_Fairy;
const int ERace_ARRAYSIZE = ERace_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERace_descriptor();
inline const ::std::string& ERace_Name(ERace value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERace_descriptor(), value);
}
inline bool ERace_Parse(
    const ::std::string& name, ERace* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERace>(
    ERace_descriptor(), name, value);
}
enum ECharacterProf {
  ECHARACTER_PROF_WARRIOR = 1,
  ECHARACTER_PROF_ASSASSIN = 2,
  ECHARACTER_PROF_MAGICIAN = 3,
  ECHARACTER_PROF_ARCHER = 4
};
bool ECharacterProf_IsValid(int value);
const ECharacterProf ECharacterProf_MIN = ECHARACTER_PROF_WARRIOR;
const ECharacterProf ECharacterProf_MAX = ECHARACTER_PROF_ARCHER;
const int ECharacterProf_ARRAYSIZE = ECharacterProf_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECharacterProf_descriptor();
inline const ::std::string& ECharacterProf_Name(ECharacterProf value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECharacterProf_descriptor(), value);
}
inline bool ECharacterProf_Parse(
    const ::std::string& name, ECharacterProf* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECharacterProf>(
    ECharacterProf_descriptor(), name, value);
}
enum CurrencyType {
  VALUE_CURRENCY_NULL = 0,
  VALUE_CURRENCY_SILVER = 1,
  VALUE_CURRENCY_GOLD = 2,
  VALUE_CURRENCY_BIND_GOLD = 3,
  VALUE_CURRENCY_REPUTATION = 5
};
bool CurrencyType_IsValid(int value);
const CurrencyType CurrencyType_MIN = VALUE_CURRENCY_NULL;
const CurrencyType CurrencyType_MAX = VALUE_CURRENCY_REPUTATION;
const int CurrencyType_ARRAYSIZE = CurrencyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CurrencyType_descriptor();
inline const ::std::string& CurrencyType_Name(CurrencyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CurrencyType_descriptor(), value);
}
inline bool CurrencyType_Parse(
    const ::std::string& name, CurrencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CurrencyType>(
    CurrencyType_descriptor(), name, value);
}
enum AttributeType {
  BASE_ATTRIBUTE = 0,
  EQUIP_ATTRIBUTE = 1,
  ATTRIBUTE_TYPE_COUNT = 2
};
bool AttributeType_IsValid(int value);
const AttributeType AttributeType_MIN = BASE_ATTRIBUTE;
const AttributeType AttributeType_MAX = ATTRIBUTE_TYPE_COUNT;
const int AttributeType_ARRAYSIZE = AttributeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AttributeType_descriptor();
inline const ::std::string& AttributeType_Name(AttributeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AttributeType_descriptor(), value);
}
inline bool AttributeType_Parse(
    const ::std::string& name, AttributeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AttributeType>(
    AttributeType_descriptor(), name, value);
}
enum SceneType {
  SCENE_TYPE_NULL = 0,
  SCENE_TYPE_CITY = 1,
  SCENE_TYPE_FIELD = 2,
  SCENE_TYPE_ARENA = 4,
  SCENE_TYPE_SINGLE_INSTANCE = 8,
  SCENE_TYPE_MULTI_INSTANCE = 16,
  SCENE_TYPE_LOGIN = 17
};
bool SceneType_IsValid(int value);
const SceneType SceneType_MIN = SCENE_TYPE_NULL;
const SceneType SceneType_MAX = SCENE_TYPE_LOGIN;
const int SceneType_ARRAYSIZE = SceneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SceneType_descriptor();
inline const ::std::string& SceneType_Name(SceneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SceneType_descriptor(), value);
}
inline bool SceneType_Parse(
    const ::std::string& name, SceneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneType>(
    SceneType_descriptor(), name, value);
}
enum SamplePolyFlags {
  SAMPLE_POLYFLAGS_WALK = 1,
  SAMPLE_POLYFLAGS_SWIM = 2,
  SAMPLE_POLYFLAGS_FORBIT_ACROSS = 4,
  SAMPLE_POLYFLAGS_DOOR = 8,
  SAMPLE_POLYFLAGS_DISABLED = 16,
  SAMPLE_POLYFLAGS_ALL = 65535
};
bool SamplePolyFlags_IsValid(int value);
const SamplePolyFlags SamplePolyFlags_MIN = SAMPLE_POLYFLAGS_WALK;
const SamplePolyFlags SamplePolyFlags_MAX = SAMPLE_POLYFLAGS_ALL;
const int SamplePolyFlags_ARRAYSIZE = SamplePolyFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* SamplePolyFlags_descriptor();
inline const ::std::string& SamplePolyFlags_Name(SamplePolyFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    SamplePolyFlags_descriptor(), value);
}
inline bool SamplePolyFlags_Parse(
    const ::std::string& name, SamplePolyFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SamplePolyFlags>(
    SamplePolyFlags_descriptor(), name, value);
}
enum MapDefine {
  MAX_NAV_POLYS = 256,
  MAX_NAV_POINT_VALUE = 768,
  INVALID_NAVMESH_POLYREF = 0
};
bool MapDefine_IsValid(int value);
const MapDefine MapDefine_MIN = INVALID_NAVMESH_POLYREF;
const MapDefine MapDefine_MAX = MAX_NAV_POINT_VALUE;
const int MapDefine_ARRAYSIZE = MapDefine_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapDefine_descriptor();
inline const ::std::string& MapDefine_Name(MapDefine value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapDefine_descriptor(), value);
}
inline bool MapDefine_Parse(
    const ::std::string& name, MapDefine* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapDefine>(
    MapDefine_descriptor(), name, value);
}
enum REGION_DEFINE {
  DEFAULT_REGION_WIDTH = 18,
  DEFAULT_REGION_HEIGHT = 18
};
bool REGION_DEFINE_IsValid(int value);
const REGION_DEFINE REGION_DEFINE_MIN = DEFAULT_REGION_WIDTH;
const REGION_DEFINE REGION_DEFINE_MAX = DEFAULT_REGION_WIDTH;
const int REGION_DEFINE_ARRAYSIZE = REGION_DEFINE_MAX + 1;

const ::google::protobuf::EnumDescriptor* REGION_DEFINE_descriptor();
inline const ::std::string& REGION_DEFINE_Name(REGION_DEFINE value) {
  return ::google::protobuf::internal::NameOfEnum(
    REGION_DEFINE_descriptor(), value);
}
inline bool REGION_DEFINE_Parse(
    const ::std::string& name, REGION_DEFINE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<REGION_DEFINE>(
    REGION_DEFINE_descriptor(), name, value);
}
enum CharacterDefine {
  MAX_CREATE_CHARACTER_COUNT = 3,
  CHARACTER_NAME_MIN_LENGTH = 6,
  CHARACTER_NAME_MAX_LENGTH = 32
};
bool CharacterDefine_IsValid(int value);
const CharacterDefine CharacterDefine_MIN = MAX_CREATE_CHARACTER_COUNT;
const CharacterDefine CharacterDefine_MAX = CHARACTER_NAME_MAX_LENGTH;
const int CharacterDefine_ARRAYSIZE = CharacterDefine_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterDefine_descriptor();
inline const ::std::string& CharacterDefine_Name(CharacterDefine value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterDefine_descriptor(), value);
}
inline bool CharacterDefine_Parse(
    const ::std::string& name, CharacterDefine* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterDefine>(
    CharacterDefine_descriptor(), name, value);
}
enum EPackageLabel {
  EPackageLabel_none = 0,
  EPackageLabel_daily = 1,
  EPackageLabel_material = 2,
  EPackageLabel_task = 3,
  EPackageLabel_equip = 4,
  EPackageLabel_limit = 5
};
bool EPackageLabel_IsValid(int value);
const EPackageLabel EPackageLabel_MIN = EPackageLabel_none;
const EPackageLabel EPackageLabel_MAX = EPackageLabel_limit;
const int EPackageLabel_ARRAYSIZE = EPackageLabel_MAX + 1;

const ::google::protobuf::EnumDescriptor* EPackageLabel_descriptor();
inline const ::std::string& EPackageLabel_Name(EPackageLabel value) {
  return ::google::protobuf::internal::NameOfEnum(
    EPackageLabel_descriptor(), value);
}
inline bool EPackageLabel_Parse(
    const ::std::string& name, EPackageLabel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EPackageLabel>(
    EPackageLabel_descriptor(), name, value);
}
enum EQuality {
  EQuality_none = 0,
  EQuality_white = 1,
  EQuality_green = 2,
  EQuality_blue = 3,
  EQuality_purple = 4,
  EQuality_gold = 5,
  EQuality_red = 6,
  EQuality_limit = 7
};
bool EQuality_IsValid(int value);
const EQuality EQuality_MIN = EQuality_none;
const EQuality EQuality_MAX = EQuality_limit;
const int EQuality_ARRAYSIZE = EQuality_MAX + 1;

const ::google::protobuf::EnumDescriptor* EQuality_descriptor();
inline const ::std::string& EQuality_Name(EQuality value) {
  return ::google::protobuf::internal::NameOfEnum(
    EQuality_descriptor(), value);
}
inline bool EQuality_Parse(
    const ::std::string& name, EQuality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EQuality>(
    EQuality_descriptor(), name, value);
}
enum EEquipPos {
  EEquipPos_none = 0,
  EEquipPos_weapon = 1,
  EEquipPos_clothes = 2,
  EEquipPos_cloak = 3,
  EEquipPos_boot = 4,
  EEquipPos_necklace = 5,
  EEquipPos_ring = 6,
  EEquipPos_bracer = 7,
  EEquipPos_talisman = 8,
  EEquipPos_fashion = 9,
  EEquipPos_wing = 10,
  EEquipPos_ring_ex = 11,
  EEquipPos_bracer_ex = 12,
  EEquipPos_limit = 13
};
bool EEquipPos_IsValid(int value);
const EEquipPos EEquipPos_MIN = EEquipPos_none;
const EEquipPos EEquipPos_MAX = EEquipPos_limit;
const int EEquipPos_ARRAYSIZE = EEquipPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* EEquipPos_descriptor();
inline const ::std::string& EEquipPos_Name(EEquipPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    EEquipPos_descriptor(), value);
}
inline bool EEquipPos_Parse(
    const ::std::string& name, EEquipPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EEquipPos>(
    EEquipPos_descriptor(), name, value);
}
enum EArg {
  EArg_DefSweepCount = 130100001,
  EArg_SweepOnePrice = 130100002,
  EArg_SweepTenPrice = 130100003,
  EArg_SecdFlopPrice = 130100004,
  EArg_ThirdFlopPrice = 130100005,
  EArg_FourthFlopPrice = 130100006,
  EArg_DeputyCollSec = 130100007,
  EArg_DigHolePrice = 130100008,
  EArg_PublishCampNoticePrice = 130100009,
  EArg_CharacterEyeShot = 130100010,
  EArg_CharLvlUpAutoPoint = 130100011,
  EArg_DeputySkillMaxLvl = 130100012,
  EArg_DeputyEveryRestEnergy = 130100013,
  EArg_DeputyCanSpeeupTime = 130100014,
  EArg_DeputyMakeContriCost = 130100015,
  EArg_DeputyMakeGoldCost = 130100016,
  EArg_DeputyMakeAddExp = 130100017,
  EArg_pkRedLine = 130100018,
  EArg_maxPkValue = 130100019,
  EArg_subPkValueTenMinutes = 130100020,
  EArg_stoneSubPkValue = 130100021,
  EArg_attackRedTime = 130100022,
  EArg_hpRed = 130100023,
  EArg_levelCannotPk = 130100024,
  EArg_RevertHP_MA = 130100030
};
bool EArg_IsValid(int value);
const EArg EArg_MIN = EArg_DefSweepCount;
const EArg EArg_MAX = EArg_RevertHP_MA;
const int EArg_ARRAYSIZE = EArg_MAX + 1;

const ::google::protobuf::EnumDescriptor* EArg_descriptor();
inline const ::std::string& EArg_Name(EArg value) {
  return ::google::protobuf::internal::NameOfEnum(
    EArg_descriptor(), value);
}
inline bool EArg_Parse(
    const ::std::string& name, EArg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EArg>(
    EArg_descriptor(), name, value);
}
enum EMailType {
  MAIL_TYPE_NORMAL = 1,
  MAIL_TYPE_TRADE = 2,
  MAIL_TYPE_SYSTEM = 3,
  MAIL_TYPE_PAY = 4,
  MAIL_TYPE_RETURN = 5
};
bool EMailType_IsValid(int value);
const EMailType EMailType_MIN = MAIL_TYPE_NORMAL;
const EMailType EMailType_MAX = MAIL_TYPE_RETURN;
const int EMailType_ARRAYSIZE = EMailType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EMailType_descriptor();
inline const ::std::string& EMailType_Name(EMailType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EMailType_descriptor(), value);
}
inline bool EMailType_Parse(
    const ::std::string& name, EMailType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EMailType>(
    EMailType_descriptor(), name, value);
}
enum EMailTradingSellType {
  MAIL_TRADING_SELL_TYPE_NONE = 0,
  MAIL_TRADING_SELL_TYPE_GOLD = 1,
  MAIL_TRADING_SELL_TYPE_DIAMOND = 2
};
bool EMailTradingSellType_IsValid(int value);
const EMailTradingSellType EMailTradingSellType_MIN = MAIL_TRADING_SELL_TYPE_NONE;
const EMailTradingSellType EMailTradingSellType_MAX = MAIL_TRADING_SELL_TYPE_DIAMOND;
const int EMailTradingSellType_ARRAYSIZE = EMailTradingSellType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EMailTradingSellType_descriptor();
inline const ::std::string& EMailTradingSellType_Name(EMailTradingSellType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EMailTradingSellType_descriptor(), value);
}
inline bool EMailTradingSellType_Parse(
    const ::std::string& name, EMailTradingSellType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EMailTradingSellType>(
    EMailTradingSellType_descriptor(), name, value);
}
enum ERetCode {
  RET_SUCCESS = 0,
  RET_FAIL = 1,
  RET_LEVEL_LACK = 2,
  RET_MONEY_LACK = 3,
  RET_GOLD_LACK = 4,
  RET_BIND_GOLD_LACK = 5,
  RET_DIAMOND_LACK = 6,
  RET_BIND_DIAMOND_LACK = 7,
  RET_VIP_LEVEL_LACK = 8,
  RET_LOGIN_BAD_USER_NAME_LEN = 100,
  RET_LOGIN_CHARACTER_NOT_EXITS = 101,
  RET_LOGIN_ACCOUNT_OTHER_LOGIN = 102,
  RET_LOGIN_CHARACTER_NUM_LIMIT = 103,
  RET_LOGIN_CHARACTER_NAME_EXISTS = 104,
  RET_LOGIN_CHARACTER_SEX_ERROR = 105,
  RET_LOGIN_CHARACTER_PROF_ERROR = 106,
  RET_LOGIN_CHARACTER_NAME_LEN_ERROR = 107,
  RET_LOGIN_CHARACTER_CREATE_FAILED = 108,
  RET_SKILL_USE_MP_LACK = 200,
  RET_SCENE_ALREADY_IN_DST_MAP = 300,
  RET_SCENE_TIMEOUT_LOADMAP = 301,
  RET_SCENE_SCENCE_NOT_EXIT = 302,
  RET_SCENE_INSCENE_SUCCESS = 303,
  RET_PACKAGE_SPACE_NOT_ENOUGH = 400,
  RET_PACKAGE_ITEM_NOT_EXITS = 401,
  RET_PACKAGE_ITEM_CAN_NOT_SELL = 402,
  RET_PACKAGE_ITEM_NUM_LACK = 403,
  RET_PACKAGE_ITEM_CAN_NOT_USE = 404,
  RET_PACKAGE_ITEM_CAN_NOT_BATCH_USE = 405,
  RET_PACKAGE_EXPAND_LIMIT = 406,
  RET_PACKAGE_ITEM_FUNC_PARAM_ERR = 407,
  RET_PACKAGE_SORT_IN_COOL = 408,
  RET_PACKAGE_LACK_STREN_MATERIAL = 409,
  RET_PACKAGE_STREN_LEVEL_LIMIT = 410,
  RET_PACKAGE_LACK_REFINE_MATERIAL = 411,
  RET_PACKAGE_REFINE_LEVEL_LIMIT = 412,
  RET_PACKAGE_HOLE_ALREADY_OPEN = 413,
  RET_PACKAGE_HOLE_NOT_OPEN = 414,
  RET_PACKAGE_ALREADY_INLAY = 415,
  RET_PACKAGE_ALREADY_INALY_SAME_TYPE = 416,
  RET_PACKAGE_INLAY_STONE_NOT_EXIST = 417,
  RET_PACKAGE_NOT_INLAY = 418,
  RET_PACKAGE_INLAY_HOLY_NOT_EXIST = 419,
  RET_PACKAGE_NOT_INLAY_HOLY = 420,
  RET_PACKAGE_NOT_CAN_STREN_EQUIP = 421,
  RET_PACKAGE_CAN_NOT_INLAY_HOLY = 422,
  RET_PACKAGE_ALREADY_INLAY_HOLY = 423,
  RET_PACKAGE_COMPOSE_MATERIAL_LACK = 424,
  RET_PACKAGE_DROP_NOT_EXITS = 425,
  RET_PACKAGE_DROP_CAN_NOT_PICK = 426,
  RET_EQUIP_EQUIP_NOT_EXIST = 500,
  RET_EQUIP_EQUIP_POS_ERR = 501,
  RET_EQUIP_POS_NOT_EXIT_EQUIP = 502,
  RET_MISSION_HAVE_ACCEPT = 600,
  RET_MISSION_CAN_NOT_ACCEPT = 601,
  RET_MISSION_LEVEL_ERROR = 602,
  RET_MISSION_NOT_EXIST = 603,
  RET_MISSION_STATE_NOT_MATCH = 604,
  RET_MISSION_PROFESSION_LIMIT = 605,
  RET_MISSION_SEX_LIMIT = 606,
  RET_MISSION_CAMP_LIMIT = 607,
  RET_MISSION_RACE_LIMIT = 608,
  RET_MISSION_MUTEX_LIMIT = 609,
  RET_MISSION_REPEAT_ACCEPT_MISSION = 610,
  RET_MISSION_TIMES_ERROR = 611,
  RET_MISSION_HAVE_ACCEPT_NUMBER_LIMIT = 612,
  RET_MISSION_HAVE_DICE = 613,
  RET_MISSION_DICE_TIMES_LIMIT = 614,
  RET_MISSION_CAN_NOT_GET_CAMP_REWARD = 615,
  RET_MISSION_NOT_OPEN_CAMP_MISSION = 616,
  RET_DUPLICATE_CAN_NOT_ENTER = 700,
  RET_DUPLICATE_ENERGY_LACK = 701,
  RET_DUPLICATE_ALREAY_IN = 702,
  RET_DUPLICATE_FLOP_NOT_OPEN = 703,
  RET_DUPLICATE_OUT_FLOP_TIME = 704,
  RET_DUPLICATE_RELIVE_NO_DEAD = 705,
  RET_DUPLICATE_PRE_NOT_PASS = 706,
  RET_DUPLICATE_MAX_LEVEL_LIMIT = 707,
  RET_DUPLICATE_FLOP_NOT_EXIST = 708,
  RET_DUPLICATE_FLOP_NUM_LIMIT = 709,
  RET_DUPLICATE_LACK_ENTER_NUM = 710,
  RET_DUPLICATE_IS_UNLOCK = 711,
  RET_DUPLICATE_AREA_NOT_EXIST = 712,
  RET_DUPLICATE_ENTER_AREA = 713,
  RET_DUPLICATE_IN_TEAM = 714,
  RET_DUPLICATE_IN_ROOM = 715,
  RET_DUPLICATE_NOT_IN_TEAM = 716,
  RET_DUPLICATE_NOT_IN_ROOM = 717,
  RET_DUPLICATE_NOT_TEM_LEADER = 718,
  RET_DUPLICATE_NOT_ROOM_LEADER = 719,
  RET_DUPLICATE_PLAYER_NUM_LIMIT = 720,
  RET_DUPLICATE_RELIVE_NUM_LIMIT = 721,
  RET_DUPLICATE_IN_ERROR_TEAM = 722,
  RET_DUPLICATE_IN_ERROR_ROOM = 723,
  RET_RELATION_HAVE_APPLY = 800,
  RET_RELATION_NOT_AGREE = 801,
  RET_RELATION_CAN_NOT_APPLY_SELF = 802,
  RET_RELATION_APPLY_GROUP_ERROR = 803,
  RET_RELATION_NOT_ADD_SELF = 804,
  RET_RELATION_NOT_IN_APPLY = 805,
  RET_RELATION_SIZE_LIMIT_NO_APPLY = 806,
  RET_RELATION_SIZE_LIMIT_NO_APPLY_OTHER = 807,
  RET_RELATION_IS_MY_FRIEND = 808,
  RET_RELATION_SIZE_LIMIT_NO_ADD = 809,
  RET_RELATION_SIZE_LIMIT_NO_ADD_OTHER = 810,
  RET_RELATION_ADD_BLACK_MYSELF = 811,
  RET_RELATION_BALCK_SIZE_LIMIT = 812,
  RET_RELATION_IN_YOUR_BALCK = 813,
  RET_RELATION_IN_OTHER_BALCK = 814,
  RET_RELATION_IN_OTHER_BALCK_CAN_NOT_APPLY = 815,
  RET_RELATION_IN_YOUR_BALCK_CAN_NOT_APPLY = 816,
  RET_RELATION_NOT_SEARCH = 817,
  RET_RELATION_NOT_FRIENDS = 818,
  RET_RELATION_HAVE_GIVE_PHYSICAL = 819,
  RET_RELATION_GIVE_PHYSICAL_TIMES_LIMIT = 820,
  RET_RELATION_GET_PHYSICAL_TIME_LIMTI = 821,
  RET_RELATION_NOT_GET_PHYSICAL = 822,
  RET_RELATION_HAVE_GET_PHYSICAL = 823,
  RET_RELATION_GET_PHYSICAL_GIFT_LIMIT = 824,
  RET_RELATION_IN_CD_TIME = 825,
  RET_CHAT_NOT_MYSELF = 900,
  RET_CHAT_TARGET_NOT_ONLINE = 901,
  RET_CHAT_TARGET_IN_BLACK = 902,
  RET_CHAT_QUREY_CHAR_NOT_EXITS = 903,
  RET_MAIL_SEND_LEVEL_LIMIT = 1001,
  RET_MAIL_SEND_TARGET_ERROR = 1002,
  RET_MAIL_DATA_ERROR = 1003,
  RET_MAIL_TRADE_NOT_SEND_OFFLINE = 1004,
  RET_MAIL_NO_SEND_TO_SELF = 1005,
  RET_MAIL_NOT_EXIST = 1006,
  RET_MAIL_SEND_TYPE_ERROR = 1007,
  RET_MAIL_TRADING_SELL_TYPE_ERROR = 1008,
  RET_MAIL_NOT_HAVE_ATTACHMENT = 1009,
  RET_MAIL_GRID_INDEX_ERROR = 1010,
  RET_MAIL_GOODS_NUM_LIMIT = 1011,
  RET_MAIL_TYPE_ERROR = 1012,
  RET_MAIL_CONTENT_LEN_LIMIT = 1013,
  RET_MAIL_TOPIC_LEN_LIMIT = 1014,
  RET_MAIL_SELL_TYPE_ERROR = 1015,
  RET_MAIL_SELL_NUM_ERROR = 1016,
  RET_MAIL_ALREDAY_FULL = 1017,
  RET_MAIL_ALREADY_FETCH = 1018,
  RET_CAMP_LEADER_CAN_PUBLISH_NOTICE = 1100,
  RET_CAMP_NOTICE_LEN_LIMIT = 1101,
  RET_CAMP_NOTICE_CD_LIMIT = 1102,
  RET_CAMP_ALREADY_IN_CAMP = 1103,
  RET_CAMP_CHANGE_CAMP_TIME_LIMIT = 1104,
  RET_CAMP_NOT_JOIN_CAMP = 1105,
  RET_CAMP_NOT_EXIST = 1106,
  RET_ACHIEVEMENT_SORTTYEP_ERROR = 1200,
  RET_ACHIEVEMENT_NOT_EXIST = 1201,
  RET_ACHIEVEMENT_REWARD_HAVE_GET = 1201,
  RET_ACHIEVEMENT_BOX_REWARD_ERROR = 1201,
  RET_ACHIEVEMENT_BOX_REWARD_POINT_LIMIT = 1202,
  RET_ACHIEVEMENT_BOX_REWARD_HAVE_GET = 1203,
  RET_SKILL_LACK_MONEY = 1301,
  RET_SKILL_CHARACTER_LEVEL_LOW = 1302,
  RET_DEPUTY_SKILL_MAX_LEVEL_LIMIT = 1400,
  RET_DEPUTY_LACK_SKILLFUL = 1401,
  RET_DEPUTY_LACK_UNION_CONTRI = 1402,
  RET_DEPUTY_MAKE_LIST_NOT_OPEN = 1403,
  RET_DEPUTY_COLLECT_LACK_ENERGY = 1404,
  RET_DEPUTY_COLLECT_BY_OTHER = 1405,
  RET_DEPUTY_LACK_LEVEL = 1406,
  RET_DEPUTY_COLLECT_BREAK = 1407,
  RET_DEPUTY_COLLECT_IN_MOVE = 1408,
  RET_DEPUTY_RES_NOT_EXIST = 1409,
  RET_MALL_BUY_COUNT_LIMIT = 1500,
  RET_MALL_GOODS_COUNT_LACK = 1501
};
bool ERetCode_IsValid(int value);
const ERetCode ERetCode_MIN = RET_SUCCESS;
const ERetCode ERetCode_MAX = RET_MALL_GOODS_COUNT_LACK;
const int ERetCode_ARRAYSIZE = ERetCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERetCode_descriptor();
inline const ::std::string& ERetCode_Name(ERetCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERetCode_descriptor(), value);
}
inline bool ERetCode_Parse(
    const ::std::string& name, ERetCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERetCode>(
    ERetCode_descriptor(), name, value);
}
enum EMODULE_ID {
  EMODULE_ID_NONE = 0,
  EMODULE_ID_SERV_SYS = 1,
  EMODULE_ID_PLAYER = 2,
  EMODULE_ID_LOGIN = 3,
  EMODULE_ID_SCENE = 4,
  EMODULE_ID_SKILL = 5,
  EMODULE_ID_BUFF = 6,
  EMODULE_ID_PACKAGE = 7,
  EMODULE_ID_TASK = 8,
  EMODULE_ID_CHAT = 9,
  EMODULE_ID_DUPLICATE = 10,
  EMODULE_ID_FRIEND = 11,
  EMODULE_ID_MOVE = 12,
  EMODULE_ID_MAIL = 13,
  EMODULE_ID_CAMP = 14,
  EMODULE_ID_ACHIEVEMENT = 15,
  EMODULE_ID_DEPUTY = 16,
  EMODULE_ID_PVP = 17,
  EMODULE_ID_MALL = 18,
  EMODULE_ID_ROOM = 19,
  EMODULE_ID_ACTIVITY = 20,
  EMODULE_ID_LIMIT = 30
};
bool EMODULE_ID_IsValid(int value);
const EMODULE_ID EMODULE_ID_MIN = EMODULE_ID_NONE;
const EMODULE_ID EMODULE_ID_MAX = EMODULE_ID_LIMIT;
const int EMODULE_ID_ARRAYSIZE = EMODULE_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* EMODULE_ID_descriptor();
inline const ::std::string& EMODULE_ID_Name(EMODULE_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    EMODULE_ID_descriptor(), value);
}
inline bool EMODULE_ID_Parse(
    const ::std::string& name, EMODULE_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EMODULE_ID>(
    EMODULE_ID_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoBuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::PROTOCOL_VERSION_UPPER>() {
  return ::ProtoBuf::PROTOCOL_VERSION_UPPER_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::PROTOCOL_VERSION_LOWER>() {
  return ::ProtoBuf::PROTOCOL_VERSION_LOWER_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::PingConfig>() {
  return ::ProtoBuf::PingConfig_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::ECharacterSex>() {
  return ::ProtoBuf::ECharacterSex_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::ERace>() {
  return ::ProtoBuf::ERace_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::ECharacterProf>() {
  return ::ProtoBuf::ECharacterProf_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::CurrencyType>() {
  return ::ProtoBuf::CurrencyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::AttributeType>() {
  return ::ProtoBuf::AttributeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::SceneType>() {
  return ::ProtoBuf::SceneType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::SamplePolyFlags>() {
  return ::ProtoBuf::SamplePolyFlags_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::MapDefine>() {
  return ::ProtoBuf::MapDefine_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::REGION_DEFINE>() {
  return ::ProtoBuf::REGION_DEFINE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::CharacterDefine>() {
  return ::ProtoBuf::CharacterDefine_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::EPackageLabel>() {
  return ::ProtoBuf::EPackageLabel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::EQuality>() {
  return ::ProtoBuf::EQuality_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::EEquipPos>() {
  return ::ProtoBuf::EEquipPos_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::EArg>() {
  return ::ProtoBuf::EArg_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::EMailType>() {
  return ::ProtoBuf::EMailType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::EMailTradingSellType>() {
  return ::ProtoBuf::EMailTradingSellType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::ERetCode>() {
  return ::ProtoBuf::ERetCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::EMODULE_ID>() {
  return ::ProtoBuf::EMODULE_ID_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Common_2fComDefine_2eproto__INCLUDED
