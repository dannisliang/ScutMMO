// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoBuffer/ClientToLogic.proto

#ifndef PROTOBUF_ProtoBuffer_2fClientToLogic_2eproto__INCLUDED
#define PROTOBUF_ProtoBuffer_2fClientToLogic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ProtoBuffer/ComProtocol.pb.h"
#include "ProtoBuffer/ClientToServerCmd.pb.h"
#include "Common/ComDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace ProtoBuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

class CSEnterSceneReq;
class PingLogicServer;
class ClientResetTimeOut;
class AccountLoginLogicRequest;
class ReconnectRequest;
class ClientCharacterListRequest;
class ClientCreateCharacterRequest;
class ClientDelCharacterReq;
class EnterWorld;
class AttrPoint;
class AutoAttrPoint;
class UseSkillReq;
class ChargeEndSKillReq;
class LevUpSkillReq;
class UseSkillStop;
class TransSceneReq;
class CheckVersionRequest;
class CheckVersionResponse;
class AccountLoginRequest;
class AccountLoginResponse;
class PingLoginRequest;
class PvpSetModeRequest;
class PvpSetModeRespone;

enum ClientResetTimeOut_Type {
  ClientResetTimeOut_Type_RETSET = 0,
  ClientResetTimeOut_Type_PLAYCG = 1
};
bool ClientResetTimeOut_Type_IsValid(int value);
const ClientResetTimeOut_Type ClientResetTimeOut_Type_Type_MIN = ClientResetTimeOut_Type_RETSET;
const ClientResetTimeOut_Type ClientResetTimeOut_Type_Type_MAX = ClientResetTimeOut_Type_PLAYCG;
const int ClientResetTimeOut_Type_Type_ARRAYSIZE = ClientResetTimeOut_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientResetTimeOut_Type_descriptor();
inline const ::std::string& ClientResetTimeOut_Type_Name(ClientResetTimeOut_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientResetTimeOut_Type_descriptor(), value);
}
inline bool ClientResetTimeOut_Type_Parse(
    const ::std::string& name, ClientResetTimeOut_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientResetTimeOut_Type>(
    ClientResetTimeOut_Type_descriptor(), name, value);
}
enum ClientResetTimeOut_Time {
  ClientResetTimeOut_Time_PLAYCG_TIME = 40
};
bool ClientResetTimeOut_Time_IsValid(int value);
const ClientResetTimeOut_Time ClientResetTimeOut_Time_Time_MIN = ClientResetTimeOut_Time_PLAYCG_TIME;
const ClientResetTimeOut_Time ClientResetTimeOut_Time_Time_MAX = ClientResetTimeOut_Time_PLAYCG_TIME;
const int ClientResetTimeOut_Time_Time_ARRAYSIZE = ClientResetTimeOut_Time_Time_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientResetTimeOut_Time_descriptor();
inline const ::std::string& ClientResetTimeOut_Time_Name(ClientResetTimeOut_Time value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientResetTimeOut_Time_descriptor(), value);
}
inline bool ClientResetTimeOut_Time_Parse(
    const ::std::string& name, ClientResetTimeOut_Time* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientResetTimeOut_Time>(
    ClientResetTimeOut_Time_descriptor(), name, value);
}
enum TransSceneReq_Type {
  TransSceneReq_Type_Test = 0,
  TransSceneReq_Type_TransPoint = 1,
  TransSceneReq_Type_Route = 2,
  TransSceneReq_Type_Free = 3
};
bool TransSceneReq_Type_IsValid(int value);
const TransSceneReq_Type TransSceneReq_Type_Type_MIN = TransSceneReq_Type_Test;
const TransSceneReq_Type TransSceneReq_Type_Type_MAX = TransSceneReq_Type_Free;
const int TransSceneReq_Type_Type_ARRAYSIZE = TransSceneReq_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransSceneReq_Type_descriptor();
inline const ::std::string& TransSceneReq_Type_Name(TransSceneReq_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransSceneReq_Type_descriptor(), value);
}
inline bool TransSceneReq_Type_Parse(
    const ::std::string& name, TransSceneReq_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransSceneReq_Type>(
    TransSceneReq_Type_descriptor(), name, value);
}
enum CheckVersionResponse_Result {
  CheckVersionResponse_Result_CHECK_VERSION_SUCCESS = 1,
  CheckVersionResponse_Result_CHECK_VERSION_REFUSE = 2,
  CheckVersionResponse_Result_SERVER_LOAD_IS_FULL = 3,
  CheckVersionResponse_Result_LOGIN_IS_CLOSED = 4,
  CheckVersionResponse_Result_LOGIN_IS_REFUSED = 5,
  CheckVersionResponse_Result_SOMETHING_ERROR = 6
};
bool CheckVersionResponse_Result_IsValid(int value);
const CheckVersionResponse_Result CheckVersionResponse_Result_Result_MIN = CheckVersionResponse_Result_CHECK_VERSION_SUCCESS;
const CheckVersionResponse_Result CheckVersionResponse_Result_Result_MAX = CheckVersionResponse_Result_SOMETHING_ERROR;
const int CheckVersionResponse_Result_Result_ARRAYSIZE = CheckVersionResponse_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* CheckVersionResponse_Result_descriptor();
inline const ::std::string& CheckVersionResponse_Result_Name(CheckVersionResponse_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    CheckVersionResponse_Result_descriptor(), value);
}
inline bool CheckVersionResponse_Result_Parse(
    const ::std::string& name, CheckVersionResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CheckVersionResponse_Result>(
    CheckVersionResponse_Result_descriptor(), name, value);
}
// ===================================================================

class CSEnterSceneReq : public ::google::protobuf::Message {
 public:
  CSEnterSceneReq();
  virtual ~CSEnterSceneReq();

  CSEnterSceneReq(const CSEnterSceneReq& from);

  inline CSEnterSceneReq& operator=(const CSEnterSceneReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSEnterSceneReq& default_instance();

  void Swap(CSEnterSceneReq* other);

  // implements Message ----------------------------------------------

  CSEnterSceneReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSEnterSceneReq& from);
  void MergeFrom(const CSEnterSceneReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mapId = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 mapid() const;
  inline void set_mapid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.CSEnterSceneReq)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 mapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static CSEnterSceneReq* default_instance_;
};
// -------------------------------------------------------------------

class PingLogicServer : public ::google::protobuf::Message {
 public:
  PingLogicServer();
  virtual ~PingLogicServer();

  PingLogicServer(const PingLogicServer& from);

  inline PingLogicServer& operator=(const PingLogicServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingLogicServer& default_instance();

  void Swap(PingLogicServer* other);

  // implements Message ----------------------------------------------

  PingLogicServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingLogicServer& from);
  void MergeFrom(const PingLogicServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 clientTick = 1;
  inline bool has_clienttick() const;
  inline void clear_clienttick();
  static const int kClientTickFieldNumber = 1;
  inline ::google::protobuf::uint64 clienttick() const;
  inline void set_clienttick(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.PingLogicServer)
 private:
  inline void set_has_clienttick();
  inline void clear_has_clienttick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 clienttick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static PingLogicServer* default_instance_;
};
// -------------------------------------------------------------------

class ClientResetTimeOut : public ::google::protobuf::Message {
 public:
  ClientResetTimeOut();
  virtual ~ClientResetTimeOut();

  ClientResetTimeOut(const ClientResetTimeOut& from);

  inline ClientResetTimeOut& operator=(const ClientResetTimeOut& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientResetTimeOut& default_instance();

  void Swap(ClientResetTimeOut* other);

  // implements Message ----------------------------------------------

  ClientResetTimeOut* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientResetTimeOut& from);
  void MergeFrom(const ClientResetTimeOut& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientResetTimeOut_Type Type;
  static const Type RETSET = ClientResetTimeOut_Type_RETSET;
  static const Type PLAYCG = ClientResetTimeOut_Type_PLAYCG;
  static inline bool Type_IsValid(int value) {
    return ClientResetTimeOut_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ClientResetTimeOut_Type_Type_MIN;
  static const Type Type_MAX =
    ClientResetTimeOut_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ClientResetTimeOut_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ClientResetTimeOut_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ClientResetTimeOut_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ClientResetTimeOut_Type_Parse(name, value);
  }

  typedef ClientResetTimeOut_Time Time;
  static const Time PLAYCG_TIME = ClientResetTimeOut_Time_PLAYCG_TIME;
  static inline bool Time_IsValid(int value) {
    return ClientResetTimeOut_Time_IsValid(value);
  }
  static const Time Time_MIN =
    ClientResetTimeOut_Time_Time_MIN;
  static const Time Time_MAX =
    ClientResetTimeOut_Time_Time_MAX;
  static const int Time_ARRAYSIZE =
    ClientResetTimeOut_Time_Time_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Time_descriptor() {
    return ClientResetTimeOut_Time_descriptor();
  }
  static inline const ::std::string& Time_Name(Time value) {
    return ClientResetTimeOut_Time_Name(value);
  }
  static inline bool Time_Parse(const ::std::string& name,
      Time* value) {
    return ClientResetTimeOut_Time_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ProtoBuf.ClientResetTimeOut.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ProtoBuf::ClientResetTimeOut_Type type() const;
  inline void set_type(::ProtoBuf::ClientResetTimeOut_Type value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.ClientResetTimeOut)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static ClientResetTimeOut* default_instance_;
};
// -------------------------------------------------------------------

class AccountLoginLogicRequest : public ::google::protobuf::Message {
 public:
  AccountLoginLogicRequest();
  virtual ~AccountLoginLogicRequest();

  AccountLoginLogicRequest(const AccountLoginLogicRequest& from);

  inline AccountLoginLogicRequest& operator=(const AccountLoginLogicRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLoginLogicRequest& default_instance();

  void Swap(AccountLoginLogicRequest* other);

  // implements Message ----------------------------------------------

  AccountLoginLogicRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountLoginLogicRequest& from);
  void MergeFrom(const AccountLoginLogicRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 groupId = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 groupid() const;
  inline void set_groupid(::google::protobuf::uint32 value);

  // required uint64 token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // required string channelId = 3;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIdFieldNumber = 3;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  inline void set_allocated_channelid(::std::string* channelid);

  // required string userId = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 4;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string userName = 5;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 5;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:ProtoBuf.AccountLoginLogicRequest)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_username();
  inline void clear_has_username();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 token_;
  ::std::string* channelid_;
  ::std::string* userid_;
  ::std::string* username_;
  ::google::protobuf::uint32 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static AccountLoginLogicRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReconnectRequest : public ::google::protobuf::Message {
 public:
  ReconnectRequest();
  virtual ~ReconnectRequest();

  ReconnectRequest(const ReconnectRequest& from);

  inline ReconnectRequest& operator=(const ReconnectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReconnectRequest& default_instance();

  void Swap(ReconnectRequest* other);

  // implements Message ----------------------------------------------

  ReconnectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReconnectRequest& from);
  void MergeFrom(const ReconnectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 accountIndex = 1;
  inline bool has_accountindex() const;
  inline void clear_accountindex();
  static const int kAccountIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 accountindex() const;
  inline void set_accountindex(::google::protobuf::uint32 value);

  // required uint32 charId = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // required uint64 token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // required string channelId = 4;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIdFieldNumber = 4;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  inline void set_allocated_channelid(::std::string* channelid);

  // required string userId = 5;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 5;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string userName = 6;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 6;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required uint64 startMark = 7;
  inline bool has_startmark() const;
  inline void clear_startmark();
  static const int kStartMarkFieldNumber = 7;
  inline ::google::protobuf::uint64 startmark() const;
  inline void set_startmark(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.ReconnectRequest)
 private:
  inline void set_has_accountindex();
  inline void clear_has_accountindex();
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_startmark();
  inline void clear_has_startmark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 accountindex_;
  ::google::protobuf::uint32 charid_;
  ::google::protobuf::uint64 token_;
  ::std::string* channelid_;
  ::std::string* userid_;
  ::std::string* username_;
  ::google::protobuf::uint64 startmark_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static ReconnectRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClientCharacterListRequest : public ::google::protobuf::Message {
 public:
  ClientCharacterListRequest();
  virtual ~ClientCharacterListRequest();

  ClientCharacterListRequest(const ClientCharacterListRequest& from);

  inline ClientCharacterListRequest& operator=(const ClientCharacterListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientCharacterListRequest& default_instance();

  void Swap(ClientCharacterListRequest* other);

  // implements Message ----------------------------------------------

  ClientCharacterListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientCharacterListRequest& from);
  void MergeFrom(const ClientCharacterListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoBuf.ClientCharacterListRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static ClientCharacterListRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClientCreateCharacterRequest : public ::google::protobuf::Message {
 public:
  ClientCreateCharacterRequest();
  virtual ~ClientCreateCharacterRequest();

  ClientCreateCharacterRequest(const ClientCreateCharacterRequest& from);

  inline ClientCreateCharacterRequest& operator=(const ClientCreateCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientCreateCharacterRequest& default_instance();

  void Swap(ClientCreateCharacterRequest* other);

  // implements Message ----------------------------------------------

  ClientCreateCharacterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientCreateCharacterRequest& from);
  void MergeFrom(const ClientCreateCharacterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 groupId = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 groupid() const;
  inline void set_groupid(::google::protobuf::uint32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 sex = 3;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // required uint32 prof = 4;
  inline bool has_prof() const;
  inline void clear_prof();
  static const int kProfFieldNumber = 4;
  inline ::google::protobuf::uint32 prof() const;
  inline void set_prof(::google::protobuf::uint32 value);

  // required uint32 race = 5;
  inline bool has_race() const;
  inline void clear_race();
  static const int kRaceFieldNumber = 5;
  inline ::google::protobuf::uint32 race() const;
  inline void set_race(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.ClientCreateCharacterRequest)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_prof();
  inline void clear_has_prof();
  inline void set_has_race();
  inline void clear_has_race();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 groupid_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::uint32 prof_;
  ::google::protobuf::uint32 race_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static ClientCreateCharacterRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClientDelCharacterReq : public ::google::protobuf::Message {
 public:
  ClientDelCharacterReq();
  virtual ~ClientDelCharacterReq();

  ClientDelCharacterReq(const ClientDelCharacterReq& from);

  inline ClientDelCharacterReq& operator=(const ClientDelCharacterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientDelCharacterReq& default_instance();

  void Swap(ClientDelCharacterReq* other);

  // implements Message ----------------------------------------------

  ClientDelCharacterReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientDelCharacterReq& from);
  void MergeFrom(const ClientDelCharacterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.ClientDelCharacterReq)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static ClientDelCharacterReq* default_instance_;
};
// -------------------------------------------------------------------

class EnterWorld : public ::google::protobuf::Message {
 public:
  EnterWorld();
  virtual ~EnterWorld();

  EnterWorld(const EnterWorld& from);

  inline EnterWorld& operator=(const EnterWorld& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterWorld& default_instance();

  void Swap(EnterWorld* other);

  // implements Message ----------------------------------------------

  EnterWorld* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterWorld& from);
  void MergeFrom(const EnterWorld& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 charId = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.EnterWorld)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static EnterWorld* default_instance_;
};
// -------------------------------------------------------------------

class AttrPoint : public ::google::protobuf::Message {
 public:
  AttrPoint();
  virtual ~AttrPoint();

  AttrPoint(const AttrPoint& from);

  inline AttrPoint& operator=(const AttrPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AttrPoint& default_instance();

  void Swap(AttrPoint* other);

  // implements Message ----------------------------------------------

  AttrPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttrPoint& from);
  void MergeFrom(const AttrPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 APoint = 1;
  inline bool has_apoint() const;
  inline void clear_apoint();
  static const int kAPointFieldNumber = 1;
  inline ::google::protobuf::uint32 apoint() const;
  inline void set_apoint(::google::protobuf::uint32 value);

  // repeated .ProtoBuf.Attr PlayerAttrs = 2;
  inline int playerattrs_size() const;
  inline void clear_playerattrs();
  static const int kPlayerAttrsFieldNumber = 2;
  inline const ::ProtoBuf::Attr& playerattrs(int index) const;
  inline ::ProtoBuf::Attr* mutable_playerattrs(int index);
  inline ::ProtoBuf::Attr* add_playerattrs();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Attr >&
      playerattrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Attr >*
      mutable_playerattrs();

  // @@protoc_insertion_point(class_scope:ProtoBuf.AttrPoint)
 private:
  inline void set_has_apoint();
  inline void clear_has_apoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Attr > playerattrs_;
  ::google::protobuf::uint32 apoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static AttrPoint* default_instance_;
};
// -------------------------------------------------------------------

class AutoAttrPoint : public ::google::protobuf::Message {
 public:
  AutoAttrPoint();
  virtual ~AutoAttrPoint();

  AutoAttrPoint(const AutoAttrPoint& from);

  inline AutoAttrPoint& operator=(const AutoAttrPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoAttrPoint& default_instance();

  void Swap(AutoAttrPoint* other);

  // implements Message ----------------------------------------------

  AutoAttrPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutoAttrPoint& from);
  void MergeFrom(const AutoAttrPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 setAuto = 1;
  inline bool has_setauto() const;
  inline void clear_setauto();
  static const int kSetAutoFieldNumber = 1;
  inline ::google::protobuf::uint32 setauto() const;
  inline void set_setauto(::google::protobuf::uint32 value);

  // repeated .ProtoBuf.Attr AutoAttrs = 2;
  inline int autoattrs_size() const;
  inline void clear_autoattrs();
  static const int kAutoAttrsFieldNumber = 2;
  inline const ::ProtoBuf::Attr& autoattrs(int index) const;
  inline ::ProtoBuf::Attr* mutable_autoattrs(int index);
  inline ::ProtoBuf::Attr* add_autoattrs();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Attr >&
      autoattrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Attr >*
      mutable_autoattrs();

  // @@protoc_insertion_point(class_scope:ProtoBuf.AutoAttrPoint)
 private:
  inline void set_has_setauto();
  inline void clear_has_setauto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Attr > autoattrs_;
  ::google::protobuf::uint32 setauto_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static AutoAttrPoint* default_instance_;
};
// -------------------------------------------------------------------

class UseSkillReq : public ::google::protobuf::Message {
 public:
  UseSkillReq();
  virtual ~UseSkillReq();

  UseSkillReq(const UseSkillReq& from);

  inline UseSkillReq& operator=(const UseSkillReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UseSkillReq& default_instance();

  void Swap(UseSkillReq* other);

  // implements Message ----------------------------------------------

  UseSkillReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UseSkillReq& from);
  void MergeFrom(const UseSkillReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 skillId = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skillid() const;
  inline void set_skillid(::google::protobuf::uint32 value);

  // required .ProtoBuf.Vector3PB dir = 2;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 2;
  inline const ::ProtoBuf::Vector3PB& dir() const;
  inline ::ProtoBuf::Vector3PB* mutable_dir();
  inline ::ProtoBuf::Vector3PB* release_dir();
  inline void set_allocated_dir(::ProtoBuf::Vector3PB* dir);

  // repeated uint32 targetCids = 3;
  inline int targetcids_size() const;
  inline void clear_targetcids();
  static const int kTargetCidsFieldNumber = 3;
  inline ::google::protobuf::uint32 targetcids(int index) const;
  inline void set_targetcids(int index, ::google::protobuf::uint32 value);
  inline void add_targetcids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      targetcids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_targetcids();

  // optional .ProtoBuf.Vector3PB targetPos = 4;
  inline bool has_targetpos() const;
  inline void clear_targetpos();
  static const int kTargetPosFieldNumber = 4;
  inline const ::ProtoBuf::Vector3PB& targetpos() const;
  inline ::ProtoBuf::Vector3PB* mutable_targetpos();
  inline ::ProtoBuf::Vector3PB* release_targetpos();
  inline void set_allocated_targetpos(::ProtoBuf::Vector3PB* targetpos);

  // @@protoc_insertion_point(class_scope:ProtoBuf.UseSkillReq)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_targetpos();
  inline void clear_has_targetpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoBuf::Vector3PB* dir_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > targetcids_;
  ::ProtoBuf::Vector3PB* targetpos_;
  ::google::protobuf::uint32 skillid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static UseSkillReq* default_instance_;
};
// -------------------------------------------------------------------

class ChargeEndSKillReq : public ::google::protobuf::Message {
 public:
  ChargeEndSKillReq();
  virtual ~ChargeEndSKillReq();

  ChargeEndSKillReq(const ChargeEndSKillReq& from);

  inline ChargeEndSKillReq& operator=(const ChargeEndSKillReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChargeEndSKillReq& default_instance();

  void Swap(ChargeEndSKillReq* other);

  // implements Message ----------------------------------------------

  ChargeEndSKillReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChargeEndSKillReq& from);
  void MergeFrom(const ChargeEndSKillReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 skillId = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skillid() const;
  inline void set_skillid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.ChargeEndSKillReq)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 skillid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static ChargeEndSKillReq* default_instance_;
};
// -------------------------------------------------------------------

class LevUpSkillReq : public ::google::protobuf::Message {
 public:
  LevUpSkillReq();
  virtual ~LevUpSkillReq();

  LevUpSkillReq(const LevUpSkillReq& from);

  inline LevUpSkillReq& operator=(const LevUpSkillReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LevUpSkillReq& default_instance();

  void Swap(LevUpSkillReq* other);

  // implements Message ----------------------------------------------

  LevUpSkillReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LevUpSkillReq& from);
  void MergeFrom(const LevUpSkillReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 skillId = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skillid() const;
  inline void set_skillid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LevUpSkillReq)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 skillid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static LevUpSkillReq* default_instance_;
};
// -------------------------------------------------------------------

class UseSkillStop : public ::google::protobuf::Message {
 public:
  UseSkillStop();
  virtual ~UseSkillStop();

  UseSkillStop(const UseSkillStop& from);

  inline UseSkillStop& operator=(const UseSkillStop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UseSkillStop& default_instance();

  void Swap(UseSkillStop* other);

  // implements Message ----------------------------------------------

  UseSkillStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UseSkillStop& from);
  void MergeFrom(const UseSkillStop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 skillId = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skillid() const;
  inline void set_skillid(::google::protobuf::uint32 value);

  // optional uint32 skillStep = 2;
  inline bool has_skillstep() const;
  inline void clear_skillstep();
  static const int kSkillStepFieldNumber = 2;
  inline ::google::protobuf::uint32 skillstep() const;
  inline void set_skillstep(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.UseSkillStop)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_skillstep();
  inline void clear_has_skillstep();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 skillid_;
  ::google::protobuf::uint32 skillstep_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static UseSkillStop* default_instance_;
};
// -------------------------------------------------------------------

class TransSceneReq : public ::google::protobuf::Message {
 public:
  TransSceneReq();
  virtual ~TransSceneReq();

  TransSceneReq(const TransSceneReq& from);

  inline TransSceneReq& operator=(const TransSceneReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransSceneReq& default_instance();

  void Swap(TransSceneReq* other);

  // implements Message ----------------------------------------------

  TransSceneReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransSceneReq& from);
  void MergeFrom(const TransSceneReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TransSceneReq_Type Type;
  static const Type Test = TransSceneReq_Type_Test;
  static const Type TransPoint = TransSceneReq_Type_TransPoint;
  static const Type Route = TransSceneReq_Type_Route;
  static const Type Free = TransSceneReq_Type_Free;
  static inline bool Type_IsValid(int value) {
    return TransSceneReq_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TransSceneReq_Type_Type_MIN;
  static const Type Type_MAX =
    TransSceneReq_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TransSceneReq_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TransSceneReq_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TransSceneReq_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TransSceneReq_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 typeId = 1;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 typeid_() const;
  inline void set_typeid_(::google::protobuf::uint32 value);

  // optional uint32 instanceId = 2;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 instanceid() const;
  inline void set_instanceid(::google::protobuf::uint32 value);

  // optional .ProtoBuf.Vector3PB dstPos = 3;
  inline bool has_dstpos() const;
  inline void clear_dstpos();
  static const int kDstPosFieldNumber = 3;
  inline const ::ProtoBuf::Vector3PB& dstpos() const;
  inline ::ProtoBuf::Vector3PB* mutable_dstpos();
  inline ::ProtoBuf::Vector3PB* release_dstpos();
  inline void set_allocated_dstpos(::ProtoBuf::Vector3PB* dstpos);

  // @@protoc_insertion_point(class_scope:ProtoBuf.TransSceneReq)
 private:
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_dstpos();
  inline void clear_has_dstpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 typeid__;
  ::google::protobuf::uint32 instanceid_;
  ::ProtoBuf::Vector3PB* dstpos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static TransSceneReq* default_instance_;
};
// -------------------------------------------------------------------

class CheckVersionRequest : public ::google::protobuf::Message {
 public:
  CheckVersionRequest();
  virtual ~CheckVersionRequest();

  CheckVersionRequest(const CheckVersionRequest& from);

  inline CheckVersionRequest& operator=(const CheckVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckVersionRequest& default_instance();

  void Swap(CheckVersionRequest* other);

  // implements Message ----------------------------------------------

  CheckVersionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckVersionRequest& from);
  void MergeFrom(const CheckVersionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional string imei = 2;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 2;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // @@protoc_insertion_point(class_scope:ProtoBuf.CheckVersionRequest)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_imei();
  inline void clear_has_imei();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* imei_;
  ::google::protobuf::uint32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static CheckVersionRequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckVersionResponse : public ::google::protobuf::Message {
 public:
  CheckVersionResponse();
  virtual ~CheckVersionResponse();

  CheckVersionResponse(const CheckVersionResponse& from);

  inline CheckVersionResponse& operator=(const CheckVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckVersionResponse& default_instance();

  void Swap(CheckVersionResponse* other);

  // implements Message ----------------------------------------------

  CheckVersionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckVersionResponse& from);
  void MergeFrom(const CheckVersionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CheckVersionResponse_Result Result;
  static const Result CHECK_VERSION_SUCCESS = CheckVersionResponse_Result_CHECK_VERSION_SUCCESS;
  static const Result CHECK_VERSION_REFUSE = CheckVersionResponse_Result_CHECK_VERSION_REFUSE;
  static const Result SERVER_LOAD_IS_FULL = CheckVersionResponse_Result_SERVER_LOAD_IS_FULL;
  static const Result LOGIN_IS_CLOSED = CheckVersionResponse_Result_LOGIN_IS_CLOSED;
  static const Result LOGIN_IS_REFUSED = CheckVersionResponse_Result_LOGIN_IS_REFUSED;
  static const Result SOMETHING_ERROR = CheckVersionResponse_Result_SOMETHING_ERROR;
  static inline bool Result_IsValid(int value) {
    return CheckVersionResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CheckVersionResponse_Result_Result_MIN;
  static const Result Result_MAX =
    CheckVersionResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CheckVersionResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return CheckVersionResponse_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return CheckVersionResponse_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return CheckVersionResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ProtoBuf.CheckVersionResponse.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::ProtoBuf::CheckVersionResponse_Result result() const;
  inline void set_result(::ProtoBuf::CheckVersionResponse_Result value);

  // optional uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.CheckVersionResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int result_;
  ::google::protobuf::uint32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static CheckVersionResponse* default_instance_;
};
// -------------------------------------------------------------------

class AccountLoginRequest : public ::google::protobuf::Message {
 public:
  AccountLoginRequest();
  virtual ~AccountLoginRequest();

  AccountLoginRequest(const AccountLoginRequest& from);

  inline AccountLoginRequest& operator=(const AccountLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLoginRequest& default_instance();

  void Swap(AccountLoginRequest* other);

  // implements Message ----------------------------------------------

  AccountLoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountLoginRequest& from);
  void MergeFrom(const AccountLoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:ProtoBuf.AccountLoginRequest)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::std::string* user_id_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static AccountLoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class AccountLoginResponse : public ::google::protobuf::Message {
 public:
  AccountLoginResponse();
  virtual ~AccountLoginResponse();

  AccountLoginResponse(const AccountLoginResponse& from);

  inline AccountLoginResponse& operator=(const AccountLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLoginResponse& default_instance();

  void Swap(AccountLoginResponse* other);

  // implements Message ----------------------------------------------

  AccountLoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountLoginResponse& from);
  void MergeFrom(const AccountLoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 retcode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);

  // optional uint32 groupID = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 2;
  inline ::google::protobuf::uint32 groupid() const;
  inline void set_groupid(::google::protobuf::uint32 value);

  // optional string logicIp = 3;
  inline bool has_logicip() const;
  inline void clear_logicip();
  static const int kLogicIpFieldNumber = 3;
  inline const ::std::string& logicip() const;
  inline void set_logicip(const ::std::string& value);
  inline void set_logicip(const char* value);
  inline void set_logicip(const char* value, size_t size);
  inline ::std::string* mutable_logicip();
  inline ::std::string* release_logicip();
  inline void set_allocated_logicip(::std::string* logicip);

  // optional uint32 logicPort = 4;
  inline bool has_logicport() const;
  inline void clear_logicport();
  static const int kLogicPortFieldNumber = 4;
  inline ::google::protobuf::uint32 logicport() const;
  inline void set_logicport(::google::protobuf::uint32 value);

  // optional uint64 logicToken = 5;
  inline bool has_logictoken() const;
  inline void clear_logictoken();
  static const int kLogicTokenFieldNumber = 5;
  inline ::google::protobuf::uint64 logictoken() const;
  inline void set_logictoken(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.AccountLoginResponse)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_logicip();
  inline void clear_has_logicip();
  inline void set_has_logicport();
  inline void clear_has_logicport();
  inline void set_has_logictoken();
  inline void clear_has_logictoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 retcode_;
  ::google::protobuf::uint32 groupid_;
  ::std::string* logicip_;
  ::google::protobuf::uint64 logictoken_;
  ::google::protobuf::uint32 logicport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static AccountLoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class PingLoginRequest : public ::google::protobuf::Message {
 public:
  PingLoginRequest();
  virtual ~PingLoginRequest();

  PingLoginRequest(const PingLoginRequest& from);

  inline PingLoginRequest& operator=(const PingLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingLoginRequest& default_instance();

  void Swap(PingLoginRequest* other);

  // implements Message ----------------------------------------------

  PingLoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingLoginRequest& from);
  void MergeFrom(const PingLoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoBuf.PingLoginRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static PingLoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class PvpSetModeRequest : public ::google::protobuf::Message {
 public:
  PvpSetModeRequest();
  virtual ~PvpSetModeRequest();

  PvpSetModeRequest(const PvpSetModeRequest& from);

  inline PvpSetModeRequest& operator=(const PvpSetModeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpSetModeRequest& default_instance();

  void Swap(PvpSetModeRequest* other);

  // implements Message ----------------------------------------------

  PvpSetModeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpSetModeRequest& from);
  void MergeFrom(const PvpSetModeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pk_mode = 1;
  inline bool has_pk_mode() const;
  inline void clear_pk_mode();
  static const int kPkModeFieldNumber = 1;
  inline ::google::protobuf::uint32 pk_mode() const;
  inline void set_pk_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.PvpSetModeRequest)
 private:
  inline void set_has_pk_mode();
  inline void clear_has_pk_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 pk_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static PvpSetModeRequest* default_instance_;
};
// -------------------------------------------------------------------

class PvpSetModeRespone : public ::google::protobuf::Message {
 public:
  PvpSetModeRespone();
  virtual ~PvpSetModeRespone();

  PvpSetModeRespone(const PvpSetModeRespone& from);

  inline PvpSetModeRespone& operator=(const PvpSetModeRespone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpSetModeRespone& default_instance();

  void Swap(PvpSetModeRespone* other);

  // implements Message ----------------------------------------------

  PvpSetModeRespone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpSetModeRespone& from);
  void MergeFrom(const PvpSetModeRespone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 retcode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);

  // required uint32 pk_mode = 2;
  inline bool has_pk_mode() const;
  inline void clear_pk_mode();
  static const int kPkModeFieldNumber = 2;
  inline ::google::protobuf::uint32 pk_mode() const;
  inline void set_pk_mode(::google::protobuf::uint32 value);

  // required uint32 cid = 3;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 3;
  inline ::google::protobuf::uint32 cid() const;
  inline void set_cid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.PvpSetModeRespone)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_pk_mode();
  inline void clear_has_pk_mode();
  inline void set_has_cid();
  inline void clear_has_cid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 retcode_;
  ::google::protobuf::uint32 pk_mode_;
  ::google::protobuf::uint32 cid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fClientToLogic_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fClientToLogic_2eproto();

  void InitAsDefaultInstance();
  static PvpSetModeRespone* default_instance_;
};
// ===================================================================


// ===================================================================

// CSEnterSceneReq

// required uint32 mapId = 1;
inline bool CSEnterSceneReq::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEnterSceneReq::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEnterSceneReq::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEnterSceneReq::clear_mapid() {
  mapid_ = 0u;
  clear_has_mapid();
}
inline ::google::protobuf::uint32 CSEnterSceneReq::mapid() const {
  return mapid_;
}
inline void CSEnterSceneReq::set_mapid(::google::protobuf::uint32 value) {
  set_has_mapid();
  mapid_ = value;
}

// -------------------------------------------------------------------

// PingLogicServer

// required uint64 clientTick = 1;
inline bool PingLogicServer::has_clienttick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingLogicServer::set_has_clienttick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingLogicServer::clear_has_clienttick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingLogicServer::clear_clienttick() {
  clienttick_ = GOOGLE_ULONGLONG(0);
  clear_has_clienttick();
}
inline ::google::protobuf::uint64 PingLogicServer::clienttick() const {
  return clienttick_;
}
inline void PingLogicServer::set_clienttick(::google::protobuf::uint64 value) {
  set_has_clienttick();
  clienttick_ = value;
}

// -------------------------------------------------------------------

// ClientResetTimeOut

// required .ProtoBuf.ClientResetTimeOut.Type type = 1;
inline bool ClientResetTimeOut::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientResetTimeOut::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientResetTimeOut::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientResetTimeOut::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ProtoBuf::ClientResetTimeOut_Type ClientResetTimeOut::type() const {
  return static_cast< ::ProtoBuf::ClientResetTimeOut_Type >(type_);
}
inline void ClientResetTimeOut::set_type(::ProtoBuf::ClientResetTimeOut_Type value) {
  assert(::ProtoBuf::ClientResetTimeOut_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AccountLoginLogicRequest

// required uint32 groupId = 1;
inline bool AccountLoginLogicRequest::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLoginLogicRequest::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLoginLogicRequest::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLoginLogicRequest::clear_groupid() {
  groupid_ = 0u;
  clear_has_groupid();
}
inline ::google::protobuf::uint32 AccountLoginLogicRequest::groupid() const {
  return groupid_;
}
inline void AccountLoginLogicRequest::set_groupid(::google::protobuf::uint32 value) {
  set_has_groupid();
  groupid_ = value;
}

// required uint64 token = 2;
inline bool AccountLoginLogicRequest::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLoginLogicRequest::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLoginLogicRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLoginLogicRequest::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 AccountLoginLogicRequest::token() const {
  return token_;
}
inline void AccountLoginLogicRequest::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
}

// required string channelId = 3;
inline bool AccountLoginLogicRequest::has_channelid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountLoginLogicRequest::set_has_channelid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountLoginLogicRequest::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountLoginLogicRequest::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& AccountLoginLogicRequest::channelid() const {
  return *channelid_;
}
inline void AccountLoginLogicRequest::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void AccountLoginLogicRequest::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void AccountLoginLogicRequest::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLoginLogicRequest::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* AccountLoginLogicRequest::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLoginLogicRequest::set_allocated_channelid(::std::string* channelid) {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    delete channelid_;
  }
  if (channelid) {
    set_has_channelid();
    channelid_ = channelid;
  } else {
    clear_has_channelid();
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userId = 4;
inline bool AccountLoginLogicRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountLoginLogicRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountLoginLogicRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountLoginLogicRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& AccountLoginLogicRequest::userid() const {
  return *userid_;
}
inline void AccountLoginLogicRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AccountLoginLogicRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AccountLoginLogicRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLoginLogicRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* AccountLoginLogicRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLoginLogicRequest::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userName = 5;
inline bool AccountLoginLogicRequest::has_username() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountLoginLogicRequest::set_has_username() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountLoginLogicRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountLoginLogicRequest::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& AccountLoginLogicRequest::username() const {
  return *username_;
}
inline void AccountLoginLogicRequest::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AccountLoginLogicRequest::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AccountLoginLogicRequest::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLoginLogicRequest::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* AccountLoginLogicRequest::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLoginLogicRequest::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReconnectRequest

// required uint32 accountIndex = 1;
inline bool ReconnectRequest::has_accountindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReconnectRequest::set_has_accountindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReconnectRequest::clear_has_accountindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReconnectRequest::clear_accountindex() {
  accountindex_ = 0u;
  clear_has_accountindex();
}
inline ::google::protobuf::uint32 ReconnectRequest::accountindex() const {
  return accountindex_;
}
inline void ReconnectRequest::set_accountindex(::google::protobuf::uint32 value) {
  set_has_accountindex();
  accountindex_ = value;
}

// required uint32 charId = 2;
inline bool ReconnectRequest::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReconnectRequest::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReconnectRequest::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReconnectRequest::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 ReconnectRequest::charid() const {
  return charid_;
}
inline void ReconnectRequest::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// required uint64 token = 3;
inline bool ReconnectRequest::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReconnectRequest::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReconnectRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReconnectRequest::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 ReconnectRequest::token() const {
  return token_;
}
inline void ReconnectRequest::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
}

// required string channelId = 4;
inline bool ReconnectRequest::has_channelid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReconnectRequest::set_has_channelid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReconnectRequest::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReconnectRequest::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& ReconnectRequest::channelid() const {
  return *channelid_;
}
inline void ReconnectRequest::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void ReconnectRequest::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void ReconnectRequest::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconnectRequest::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* ReconnectRequest::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconnectRequest::set_allocated_channelid(::std::string* channelid) {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    delete channelid_;
  }
  if (channelid) {
    set_has_channelid();
    channelid_ = channelid;
  } else {
    clear_has_channelid();
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userId = 5;
inline bool ReconnectRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReconnectRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReconnectRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReconnectRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& ReconnectRequest::userid() const {
  return *userid_;
}
inline void ReconnectRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ReconnectRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ReconnectRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconnectRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* ReconnectRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconnectRequest::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userName = 6;
inline bool ReconnectRequest::has_username() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReconnectRequest::set_has_username() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReconnectRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReconnectRequest::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReconnectRequest::username() const {
  return *username_;
}
inline void ReconnectRequest::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReconnectRequest::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReconnectRequest::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconnectRequest::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReconnectRequest::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconnectRequest::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 startMark = 7;
inline bool ReconnectRequest::has_startmark() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReconnectRequest::set_has_startmark() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReconnectRequest::clear_has_startmark() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReconnectRequest::clear_startmark() {
  startmark_ = GOOGLE_ULONGLONG(0);
  clear_has_startmark();
}
inline ::google::protobuf::uint64 ReconnectRequest::startmark() const {
  return startmark_;
}
inline void ReconnectRequest::set_startmark(::google::protobuf::uint64 value) {
  set_has_startmark();
  startmark_ = value;
}

// -------------------------------------------------------------------

// ClientCharacterListRequest

// -------------------------------------------------------------------

// ClientCreateCharacterRequest

// required uint32 groupId = 1;
inline bool ClientCreateCharacterRequest::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientCreateCharacterRequest::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientCreateCharacterRequest::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientCreateCharacterRequest::clear_groupid() {
  groupid_ = 0u;
  clear_has_groupid();
}
inline ::google::protobuf::uint32 ClientCreateCharacterRequest::groupid() const {
  return groupid_;
}
inline void ClientCreateCharacterRequest::set_groupid(::google::protobuf::uint32 value) {
  set_has_groupid();
  groupid_ = value;
}

// required string name = 2;
inline bool ClientCreateCharacterRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientCreateCharacterRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientCreateCharacterRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientCreateCharacterRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClientCreateCharacterRequest::name() const {
  return *name_;
}
inline void ClientCreateCharacterRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientCreateCharacterRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientCreateCharacterRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientCreateCharacterRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClientCreateCharacterRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientCreateCharacterRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 sex = 3;
inline bool ClientCreateCharacterRequest::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientCreateCharacterRequest::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientCreateCharacterRequest::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientCreateCharacterRequest::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 ClientCreateCharacterRequest::sex() const {
  return sex_;
}
inline void ClientCreateCharacterRequest::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// required uint32 prof = 4;
inline bool ClientCreateCharacterRequest::has_prof() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientCreateCharacterRequest::set_has_prof() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientCreateCharacterRequest::clear_has_prof() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientCreateCharacterRequest::clear_prof() {
  prof_ = 0u;
  clear_has_prof();
}
inline ::google::protobuf::uint32 ClientCreateCharacterRequest::prof() const {
  return prof_;
}
inline void ClientCreateCharacterRequest::set_prof(::google::protobuf::uint32 value) {
  set_has_prof();
  prof_ = value;
}

// required uint32 race = 5;
inline bool ClientCreateCharacterRequest::has_race() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientCreateCharacterRequest::set_has_race() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientCreateCharacterRequest::clear_has_race() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientCreateCharacterRequest::clear_race() {
  race_ = 0u;
  clear_has_race();
}
inline ::google::protobuf::uint32 ClientCreateCharacterRequest::race() const {
  return race_;
}
inline void ClientCreateCharacterRequest::set_race(::google::protobuf::uint32 value) {
  set_has_race();
  race_ = value;
}

// -------------------------------------------------------------------

// ClientDelCharacterReq

// required uint32 charid = 1;
inline bool ClientDelCharacterReq::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDelCharacterReq::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDelCharacterReq::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDelCharacterReq::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 ClientDelCharacterReq::charid() const {
  return charid_;
}
inline void ClientDelCharacterReq::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// EnterWorld

// required uint32 charId = 1;
inline bool EnterWorld::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterWorld::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterWorld::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterWorld::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 EnterWorld::charid() const {
  return charid_;
}
inline void EnterWorld::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// AttrPoint

// required uint32 APoint = 1;
inline bool AttrPoint::has_apoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttrPoint::set_has_apoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttrPoint::clear_has_apoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttrPoint::clear_apoint() {
  apoint_ = 0u;
  clear_has_apoint();
}
inline ::google::protobuf::uint32 AttrPoint::apoint() const {
  return apoint_;
}
inline void AttrPoint::set_apoint(::google::protobuf::uint32 value) {
  set_has_apoint();
  apoint_ = value;
}

// repeated .ProtoBuf.Attr PlayerAttrs = 2;
inline int AttrPoint::playerattrs_size() const {
  return playerattrs_.size();
}
inline void AttrPoint::clear_playerattrs() {
  playerattrs_.Clear();
}
inline const ::ProtoBuf::Attr& AttrPoint::playerattrs(int index) const {
  return playerattrs_.Get(index);
}
inline ::ProtoBuf::Attr* AttrPoint::mutable_playerattrs(int index) {
  return playerattrs_.Mutable(index);
}
inline ::ProtoBuf::Attr* AttrPoint::add_playerattrs() {
  return playerattrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Attr >&
AttrPoint::playerattrs() const {
  return playerattrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Attr >*
AttrPoint::mutable_playerattrs() {
  return &playerattrs_;
}

// -------------------------------------------------------------------

// AutoAttrPoint

// required uint32 setAuto = 1;
inline bool AutoAttrPoint::has_setauto() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutoAttrPoint::set_has_setauto() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutoAttrPoint::clear_has_setauto() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutoAttrPoint::clear_setauto() {
  setauto_ = 0u;
  clear_has_setauto();
}
inline ::google::protobuf::uint32 AutoAttrPoint::setauto() const {
  return setauto_;
}
inline void AutoAttrPoint::set_setauto(::google::protobuf::uint32 value) {
  set_has_setauto();
  setauto_ = value;
}

// repeated .ProtoBuf.Attr AutoAttrs = 2;
inline int AutoAttrPoint::autoattrs_size() const {
  return autoattrs_.size();
}
inline void AutoAttrPoint::clear_autoattrs() {
  autoattrs_.Clear();
}
inline const ::ProtoBuf::Attr& AutoAttrPoint::autoattrs(int index) const {
  return autoattrs_.Get(index);
}
inline ::ProtoBuf::Attr* AutoAttrPoint::mutable_autoattrs(int index) {
  return autoattrs_.Mutable(index);
}
inline ::ProtoBuf::Attr* AutoAttrPoint::add_autoattrs() {
  return autoattrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Attr >&
AutoAttrPoint::autoattrs() const {
  return autoattrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::Attr >*
AutoAttrPoint::mutable_autoattrs() {
  return &autoattrs_;
}

// -------------------------------------------------------------------

// UseSkillReq

// required uint32 skillId = 1;
inline bool UseSkillReq::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UseSkillReq::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UseSkillReq::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UseSkillReq::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 UseSkillReq::skillid() const {
  return skillid_;
}
inline void UseSkillReq::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
}

// required .ProtoBuf.Vector3PB dir = 2;
inline bool UseSkillReq::has_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UseSkillReq::set_has_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UseSkillReq::clear_has_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UseSkillReq::clear_dir() {
  if (dir_ != NULL) dir_->::ProtoBuf::Vector3PB::Clear();
  clear_has_dir();
}
inline const ::ProtoBuf::Vector3PB& UseSkillReq::dir() const {
  return dir_ != NULL ? *dir_ : *default_instance_->dir_;
}
inline ::ProtoBuf::Vector3PB* UseSkillReq::mutable_dir() {
  set_has_dir();
  if (dir_ == NULL) dir_ = new ::ProtoBuf::Vector3PB;
  return dir_;
}
inline ::ProtoBuf::Vector3PB* UseSkillReq::release_dir() {
  clear_has_dir();
  ::ProtoBuf::Vector3PB* temp = dir_;
  dir_ = NULL;
  return temp;
}
inline void UseSkillReq::set_allocated_dir(::ProtoBuf::Vector3PB* dir) {
  delete dir_;
  dir_ = dir;
  if (dir) {
    set_has_dir();
  } else {
    clear_has_dir();
  }
}

// repeated uint32 targetCids = 3;
inline int UseSkillReq::targetcids_size() const {
  return targetcids_.size();
}
inline void UseSkillReq::clear_targetcids() {
  targetcids_.Clear();
}
inline ::google::protobuf::uint32 UseSkillReq::targetcids(int index) const {
  return targetcids_.Get(index);
}
inline void UseSkillReq::set_targetcids(int index, ::google::protobuf::uint32 value) {
  targetcids_.Set(index, value);
}
inline void UseSkillReq::add_targetcids(::google::protobuf::uint32 value) {
  targetcids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UseSkillReq::targetcids() const {
  return targetcids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UseSkillReq::mutable_targetcids() {
  return &targetcids_;
}

// optional .ProtoBuf.Vector3PB targetPos = 4;
inline bool UseSkillReq::has_targetpos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UseSkillReq::set_has_targetpos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UseSkillReq::clear_has_targetpos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UseSkillReq::clear_targetpos() {
  if (targetpos_ != NULL) targetpos_->::ProtoBuf::Vector3PB::Clear();
  clear_has_targetpos();
}
inline const ::ProtoBuf::Vector3PB& UseSkillReq::targetpos() const {
  return targetpos_ != NULL ? *targetpos_ : *default_instance_->targetpos_;
}
inline ::ProtoBuf::Vector3PB* UseSkillReq::mutable_targetpos() {
  set_has_targetpos();
  if (targetpos_ == NULL) targetpos_ = new ::ProtoBuf::Vector3PB;
  return targetpos_;
}
inline ::ProtoBuf::Vector3PB* UseSkillReq::release_targetpos() {
  clear_has_targetpos();
  ::ProtoBuf::Vector3PB* temp = targetpos_;
  targetpos_ = NULL;
  return temp;
}
inline void UseSkillReq::set_allocated_targetpos(::ProtoBuf::Vector3PB* targetpos) {
  delete targetpos_;
  targetpos_ = targetpos;
  if (targetpos) {
    set_has_targetpos();
  } else {
    clear_has_targetpos();
  }
}

// -------------------------------------------------------------------

// ChargeEndSKillReq

// required uint32 skillId = 1;
inline bool ChargeEndSKillReq::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChargeEndSKillReq::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChargeEndSKillReq::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChargeEndSKillReq::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 ChargeEndSKillReq::skillid() const {
  return skillid_;
}
inline void ChargeEndSKillReq::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
}

// -------------------------------------------------------------------

// LevUpSkillReq

// required uint32 skillId = 1;
inline bool LevUpSkillReq::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LevUpSkillReq::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LevUpSkillReq::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LevUpSkillReq::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 LevUpSkillReq::skillid() const {
  return skillid_;
}
inline void LevUpSkillReq::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
}

// -------------------------------------------------------------------

// UseSkillStop

// required uint32 skillId = 1;
inline bool UseSkillStop::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UseSkillStop::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UseSkillStop::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UseSkillStop::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 UseSkillStop::skillid() const {
  return skillid_;
}
inline void UseSkillStop::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
}

// optional uint32 skillStep = 2;
inline bool UseSkillStop::has_skillstep() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UseSkillStop::set_has_skillstep() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UseSkillStop::clear_has_skillstep() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UseSkillStop::clear_skillstep() {
  skillstep_ = 0u;
  clear_has_skillstep();
}
inline ::google::protobuf::uint32 UseSkillStop::skillstep() const {
  return skillstep_;
}
inline void UseSkillStop::set_skillstep(::google::protobuf::uint32 value) {
  set_has_skillstep();
  skillstep_ = value;
}

// -------------------------------------------------------------------

// TransSceneReq

// required uint32 typeId = 1;
inline bool TransSceneReq::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransSceneReq::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransSceneReq::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransSceneReq::clear_typeid_() {
  typeid__ = 0u;
  clear_has_typeid_();
}
inline ::google::protobuf::uint32 TransSceneReq::typeid_() const {
  return typeid__;
}
inline void TransSceneReq::set_typeid_(::google::protobuf::uint32 value) {
  set_has_typeid_();
  typeid__ = value;
}

// optional uint32 instanceId = 2;
inline bool TransSceneReq::has_instanceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransSceneReq::set_has_instanceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransSceneReq::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransSceneReq::clear_instanceid() {
  instanceid_ = 0u;
  clear_has_instanceid();
}
inline ::google::protobuf::uint32 TransSceneReq::instanceid() const {
  return instanceid_;
}
inline void TransSceneReq::set_instanceid(::google::protobuf::uint32 value) {
  set_has_instanceid();
  instanceid_ = value;
}

// optional .ProtoBuf.Vector3PB dstPos = 3;
inline bool TransSceneReq::has_dstpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransSceneReq::set_has_dstpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransSceneReq::clear_has_dstpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransSceneReq::clear_dstpos() {
  if (dstpos_ != NULL) dstpos_->::ProtoBuf::Vector3PB::Clear();
  clear_has_dstpos();
}
inline const ::ProtoBuf::Vector3PB& TransSceneReq::dstpos() const {
  return dstpos_ != NULL ? *dstpos_ : *default_instance_->dstpos_;
}
inline ::ProtoBuf::Vector3PB* TransSceneReq::mutable_dstpos() {
  set_has_dstpos();
  if (dstpos_ == NULL) dstpos_ = new ::ProtoBuf::Vector3PB;
  return dstpos_;
}
inline ::ProtoBuf::Vector3PB* TransSceneReq::release_dstpos() {
  clear_has_dstpos();
  ::ProtoBuf::Vector3PB* temp = dstpos_;
  dstpos_ = NULL;
  return temp;
}
inline void TransSceneReq::set_allocated_dstpos(::ProtoBuf::Vector3PB* dstpos) {
  delete dstpos_;
  dstpos_ = dstpos;
  if (dstpos) {
    set_has_dstpos();
  } else {
    clear_has_dstpos();
  }
}

// -------------------------------------------------------------------

// CheckVersionRequest

// required uint32 version = 1;
inline bool CheckVersionRequest::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckVersionRequest::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckVersionRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckVersionRequest::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 CheckVersionRequest::version() const {
  return version_;
}
inline void CheckVersionRequest::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// optional string imei = 2;
inline bool CheckVersionRequest::has_imei() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckVersionRequest::set_has_imei() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckVersionRequest::clear_has_imei() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckVersionRequest::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& CheckVersionRequest::imei() const {
  return *imei_;
}
inline void CheckVersionRequest::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void CheckVersionRequest::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void CheckVersionRequest::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckVersionRequest::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* CheckVersionRequest::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckVersionRequest::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CheckVersionResponse

// required .ProtoBuf.CheckVersionResponse.Result result = 1;
inline bool CheckVersionResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckVersionResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckVersionResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckVersionResponse::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::ProtoBuf::CheckVersionResponse_Result CheckVersionResponse::result() const {
  return static_cast< ::ProtoBuf::CheckVersionResponse_Result >(result_);
}
inline void CheckVersionResponse::set_result(::ProtoBuf::CheckVersionResponse_Result value) {
  assert(::ProtoBuf::CheckVersionResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional uint32 version = 2;
inline bool CheckVersionResponse::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckVersionResponse::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckVersionResponse::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckVersionResponse::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 CheckVersionResponse::version() const {
  return version_;
}
inline void CheckVersionResponse::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// AccountLoginRequest

// required string user_name = 1;
inline bool AccountLoginRequest::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLoginRequest::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLoginRequest::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLoginRequest::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& AccountLoginRequest::user_name() const {
  return *user_name_;
}
inline void AccountLoginRequest::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void AccountLoginRequest::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void AccountLoginRequest::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLoginRequest::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* AccountLoginRequest::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLoginRequest::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user_id = 2;
inline bool AccountLoginRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLoginRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLoginRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLoginRequest::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& AccountLoginRequest::user_id() const {
  return *user_id_;
}
inline void AccountLoginRequest::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void AccountLoginRequest::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void AccountLoginRequest::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLoginRequest::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* AccountLoginRequest::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLoginRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 3;
inline bool AccountLoginRequest::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountLoginRequest::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountLoginRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountLoginRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& AccountLoginRequest::token() const {
  return *token_;
}
inline void AccountLoginRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AccountLoginRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AccountLoginRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLoginRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* AccountLoginRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLoginRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccountLoginResponse

// required int32 retcode = 1;
inline bool AccountLoginResponse::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLoginResponse::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLoginResponse::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLoginResponse::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 AccountLoginResponse::retcode() const {
  return retcode_;
}
inline void AccountLoginResponse::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional uint32 groupID = 2;
inline bool AccountLoginResponse::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLoginResponse::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLoginResponse::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLoginResponse::clear_groupid() {
  groupid_ = 0u;
  clear_has_groupid();
}
inline ::google::protobuf::uint32 AccountLoginResponse::groupid() const {
  return groupid_;
}
inline void AccountLoginResponse::set_groupid(::google::protobuf::uint32 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional string logicIp = 3;
inline bool AccountLoginResponse::has_logicip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountLoginResponse::set_has_logicip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountLoginResponse::clear_has_logicip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountLoginResponse::clear_logicip() {
  if (logicip_ != &::google::protobuf::internal::kEmptyString) {
    logicip_->clear();
  }
  clear_has_logicip();
}
inline const ::std::string& AccountLoginResponse::logicip() const {
  return *logicip_;
}
inline void AccountLoginResponse::set_logicip(const ::std::string& value) {
  set_has_logicip();
  if (logicip_ == &::google::protobuf::internal::kEmptyString) {
    logicip_ = new ::std::string;
  }
  logicip_->assign(value);
}
inline void AccountLoginResponse::set_logicip(const char* value) {
  set_has_logicip();
  if (logicip_ == &::google::protobuf::internal::kEmptyString) {
    logicip_ = new ::std::string;
  }
  logicip_->assign(value);
}
inline void AccountLoginResponse::set_logicip(const char* value, size_t size) {
  set_has_logicip();
  if (logicip_ == &::google::protobuf::internal::kEmptyString) {
    logicip_ = new ::std::string;
  }
  logicip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLoginResponse::mutable_logicip() {
  set_has_logicip();
  if (logicip_ == &::google::protobuf::internal::kEmptyString) {
    logicip_ = new ::std::string;
  }
  return logicip_;
}
inline ::std::string* AccountLoginResponse::release_logicip() {
  clear_has_logicip();
  if (logicip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logicip_;
    logicip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLoginResponse::set_allocated_logicip(::std::string* logicip) {
  if (logicip_ != &::google::protobuf::internal::kEmptyString) {
    delete logicip_;
  }
  if (logicip) {
    set_has_logicip();
    logicip_ = logicip;
  } else {
    clear_has_logicip();
    logicip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 logicPort = 4;
inline bool AccountLoginResponse::has_logicport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountLoginResponse::set_has_logicport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountLoginResponse::clear_has_logicport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountLoginResponse::clear_logicport() {
  logicport_ = 0u;
  clear_has_logicport();
}
inline ::google::protobuf::uint32 AccountLoginResponse::logicport() const {
  return logicport_;
}
inline void AccountLoginResponse::set_logicport(::google::protobuf::uint32 value) {
  set_has_logicport();
  logicport_ = value;
}

// optional uint64 logicToken = 5;
inline bool AccountLoginResponse::has_logictoken() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountLoginResponse::set_has_logictoken() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountLoginResponse::clear_has_logictoken() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountLoginResponse::clear_logictoken() {
  logictoken_ = GOOGLE_ULONGLONG(0);
  clear_has_logictoken();
}
inline ::google::protobuf::uint64 AccountLoginResponse::logictoken() const {
  return logictoken_;
}
inline void AccountLoginResponse::set_logictoken(::google::protobuf::uint64 value) {
  set_has_logictoken();
  logictoken_ = value;
}

// -------------------------------------------------------------------

// PingLoginRequest

// -------------------------------------------------------------------

// PvpSetModeRequest

// required uint32 pk_mode = 1;
inline bool PvpSetModeRequest::has_pk_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpSetModeRequest::set_has_pk_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpSetModeRequest::clear_has_pk_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpSetModeRequest::clear_pk_mode() {
  pk_mode_ = 0u;
  clear_has_pk_mode();
}
inline ::google::protobuf::uint32 PvpSetModeRequest::pk_mode() const {
  return pk_mode_;
}
inline void PvpSetModeRequest::set_pk_mode(::google::protobuf::uint32 value) {
  set_has_pk_mode();
  pk_mode_ = value;
}

// -------------------------------------------------------------------

// PvpSetModeRespone

// required int32 retcode = 1;
inline bool PvpSetModeRespone::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpSetModeRespone::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpSetModeRespone::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpSetModeRespone::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 PvpSetModeRespone::retcode() const {
  return retcode_;
}
inline void PvpSetModeRespone::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// required uint32 pk_mode = 2;
inline bool PvpSetModeRespone::has_pk_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpSetModeRespone::set_has_pk_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpSetModeRespone::clear_has_pk_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpSetModeRespone::clear_pk_mode() {
  pk_mode_ = 0u;
  clear_has_pk_mode();
}
inline ::google::protobuf::uint32 PvpSetModeRespone::pk_mode() const {
  return pk_mode_;
}
inline void PvpSetModeRespone::set_pk_mode(::google::protobuf::uint32 value) {
  set_has_pk_mode();
  pk_mode_ = value;
}

// required uint32 cid = 3;
inline bool PvpSetModeRespone::has_cid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpSetModeRespone::set_has_cid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpSetModeRespone::clear_has_cid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpSetModeRespone::clear_cid() {
  cid_ = 0u;
  clear_has_cid();
}
inline ::google::protobuf::uint32 PvpSetModeRespone::cid() const {
  return cid_;
}
inline void PvpSetModeRespone::set_cid(::google::protobuf::uint32 value) {
  set_has_cid();
  cid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoBuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::ClientResetTimeOut_Type>() {
  return ::ProtoBuf::ClientResetTimeOut_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::ClientResetTimeOut_Time>() {
  return ::ProtoBuf::ClientResetTimeOut_Time_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::TransSceneReq_Type>() {
  return ::ProtoBuf::TransSceneReq_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::CheckVersionResponse_Result>() {
  return ::ProtoBuf::CheckVersionResponse_Result_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoBuffer_2fClientToLogic_2eproto__INCLUDED
