// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoBuffer/ServerInternalProtocol.proto

#ifndef PROTOBUF_ProtoBuffer_2fServerInternalProtocol_2eproto__INCLUDED
#define PROTOBUF_ProtoBuffer_2fServerInternalProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ProtoBuffer/ComProtocol.pb.h"
#include "Common/ComDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace ProtoBuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

class LoginServerRegiste;
class LogicServerRegiste;
class LoginServerState;
class LogicServerState;
class AccountLoginCheckReq;
class AccountLoginCheckRsp;
class AccountLogoutNotify;
class LogicCheckTokenReq;
class LogicCheckTokenRsp;
class KickChannelUserNotify;
class CenterAccountLogoutNotify;
class ReconnectCheckRequest;
class ReconnectCheckResponse;
class LogicServerAddressReq;
class LoginLogicRequest;
class LoginLogicResponse;
class LoginLogicResponse_SwitchServerParam;
class SwitchServerBeginNotify;
class BroadcastToLogicServer;
class LogicToCenterCreateChar;
class LogicToCenterDelChar;
class LogicToCenterCharSync;
class EnterLogicRequest;
class LogoutLogicRequest;
class AllocLogicNodeRequest;
class AllocLogicNodeResponse;
class ClientNotifyToClient;
class DBProxyAddrInfo;
class CenterRspSceneId;
class CenterDailyUpdateNotify;
class CenterWeekUpdateNotify;

enum LogicServerRegiste_TYPE {
  LogicServerRegiste_TYPE_FIRST = 1,
  LogicServerRegiste_TYPE_RECONNECT = 2
};
bool LogicServerRegiste_TYPE_IsValid(int value);
const LogicServerRegiste_TYPE LogicServerRegiste_TYPE_TYPE_MIN = LogicServerRegiste_TYPE_FIRST;
const LogicServerRegiste_TYPE LogicServerRegiste_TYPE_TYPE_MAX = LogicServerRegiste_TYPE_RECONNECT;
const int LogicServerRegiste_TYPE_TYPE_ARRAYSIZE = LogicServerRegiste_TYPE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogicServerRegiste_TYPE_descriptor();
inline const ::std::string& LogicServerRegiste_TYPE_Name(LogicServerRegiste_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogicServerRegiste_TYPE_descriptor(), value);
}
inline bool LogicServerRegiste_TYPE_Parse(
    const ::std::string& name, LogicServerRegiste_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogicServerRegiste_TYPE>(
    LogicServerRegiste_TYPE_descriptor(), name, value);
}
enum CenterAccountLogoutNotify_TYPE {
  CenterAccountLogoutNotify_TYPE_TOKEN_EXPIRED = 1,
  CenterAccountLogoutNotify_TYPE_CHARACTER_LOGOUT = 2
};
bool CenterAccountLogoutNotify_TYPE_IsValid(int value);
const CenterAccountLogoutNotify_TYPE CenterAccountLogoutNotify_TYPE_TYPE_MIN = CenterAccountLogoutNotify_TYPE_TOKEN_EXPIRED;
const CenterAccountLogoutNotify_TYPE CenterAccountLogoutNotify_TYPE_TYPE_MAX = CenterAccountLogoutNotify_TYPE_CHARACTER_LOGOUT;
const int CenterAccountLogoutNotify_TYPE_TYPE_ARRAYSIZE = CenterAccountLogoutNotify_TYPE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CenterAccountLogoutNotify_TYPE_descriptor();
inline const ::std::string& CenterAccountLogoutNotify_TYPE_Name(CenterAccountLogoutNotify_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CenterAccountLogoutNotify_TYPE_descriptor(), value);
}
inline bool CenterAccountLogoutNotify_TYPE_Parse(
    const ::std::string& name, CenterAccountLogoutNotify_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CenterAccountLogoutNotify_TYPE>(
    CenterAccountLogoutNotify_TYPE_descriptor(), name, value);
}
enum LoginLogicResponse_RESULT {
  LoginLogicResponse_RESULT_LOGIN_LOGIC_SUCESS = 0,
  LoginLogicResponse_RESULT_LOGIN_LOGIC_FAIL = 1
};
bool LoginLogicResponse_RESULT_IsValid(int value);
const LoginLogicResponse_RESULT LoginLogicResponse_RESULT_RESULT_MIN = LoginLogicResponse_RESULT_LOGIN_LOGIC_SUCESS;
const LoginLogicResponse_RESULT LoginLogicResponse_RESULT_RESULT_MAX = LoginLogicResponse_RESULT_LOGIN_LOGIC_FAIL;
const int LoginLogicResponse_RESULT_RESULT_ARRAYSIZE = LoginLogicResponse_RESULT_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginLogicResponse_RESULT_descriptor();
inline const ::std::string& LoginLogicResponse_RESULT_Name(LoginLogicResponse_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginLogicResponse_RESULT_descriptor(), value);
}
inline bool LoginLogicResponse_RESULT_Parse(
    const ::std::string& name, LoginLogicResponse_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginLogicResponse_RESULT>(
    LoginLogicResponse_RESULT_descriptor(), name, value);
}
enum LogoutLogicRequest_FLAG {
  LogoutLogicRequest_FLAG_LOGOUT_FLAG_GAMING = 0,
  LogoutLogicRequest_FLAG_LOGOUT_FLAG_KICKOUT = 1,
  LogoutLogicRequest_FLAG_LOGOUT_FLAG_LOGIN_BREAK = 2,
  LogoutLogicRequest_FLAG_LOGOUT_FLAG_SWITCH_SERVER = 3
};
bool LogoutLogicRequest_FLAG_IsValid(int value);
const LogoutLogicRequest_FLAG LogoutLogicRequest_FLAG_FLAG_MIN = LogoutLogicRequest_FLAG_LOGOUT_FLAG_GAMING;
const LogoutLogicRequest_FLAG LogoutLogicRequest_FLAG_FLAG_MAX = LogoutLogicRequest_FLAG_LOGOUT_FLAG_SWITCH_SERVER;
const int LogoutLogicRequest_FLAG_FLAG_ARRAYSIZE = LogoutLogicRequest_FLAG_FLAG_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogoutLogicRequest_FLAG_descriptor();
inline const ::std::string& LogoutLogicRequest_FLAG_Name(LogoutLogicRequest_FLAG value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogoutLogicRequest_FLAG_descriptor(), value);
}
inline bool LogoutLogicRequest_FLAG_Parse(
    const ::std::string& name, LogoutLogicRequest_FLAG* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogoutLogicRequest_FLAG>(
    LogoutLogicRequest_FLAG_descriptor(), name, value);
}
// ===================================================================

class LoginServerRegiste : public ::google::protobuf::Message {
 public:
  LoginServerRegiste();
  virtual ~LoginServerRegiste();

  LoginServerRegiste(const LoginServerRegiste& from);

  inline LoginServerRegiste& operator=(const LoginServerRegiste& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginServerRegiste& default_instance();

  void Swap(LoginServerRegiste* other);

  // implements Message ----------------------------------------------

  LoginServerRegiste* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginServerRegiste& from);
  void MergeFrom(const LoginServerRegiste& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 groupId = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 groupid() const;
  inline void set_groupid(::google::protobuf::uint32 value);

  // required uint32 serverId = 2;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 serverid() const;
  inline void set_serverid(::google::protobuf::uint32 value);

  // required uint32 outerPort = 3;
  inline bool has_outerport() const;
  inline void clear_outerport();
  static const int kOuterPortFieldNumber = 3;
  inline ::google::protobuf::uint32 outerport() const;
  inline void set_outerport(::google::protobuf::uint32 value);

  // required string outerIp = 4;
  inline bool has_outerip() const;
  inline void clear_outerip();
  static const int kOuterIpFieldNumber = 4;
  inline const ::std::string& outerip() const;
  inline void set_outerip(const ::std::string& value);
  inline void set_outerip(const char* value);
  inline void set_outerip(const char* value, size_t size);
  inline ::std::string* mutable_outerip();
  inline ::std::string* release_outerip();
  inline void set_allocated_outerip(::std::string* outerip);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LoginServerRegiste)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_outerport();
  inline void clear_has_outerport();
  inline void set_has_outerip();
  inline void clear_has_outerip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 groupid_;
  ::google::protobuf::uint32 serverid_;
  ::std::string* outerip_;
  ::google::protobuf::uint32 outerport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LoginServerRegiste* default_instance_;
};
// -------------------------------------------------------------------

class LogicServerRegiste : public ::google::protobuf::Message {
 public:
  LogicServerRegiste();
  virtual ~LogicServerRegiste();

  LogicServerRegiste(const LogicServerRegiste& from);

  inline LogicServerRegiste& operator=(const LogicServerRegiste& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicServerRegiste& default_instance();

  void Swap(LogicServerRegiste* other);

  // implements Message ----------------------------------------------

  LogicServerRegiste* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicServerRegiste& from);
  void MergeFrom(const LogicServerRegiste& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LogicServerRegiste_TYPE TYPE;
  static const TYPE FIRST = LogicServerRegiste_TYPE_FIRST;
  static const TYPE RECONNECT = LogicServerRegiste_TYPE_RECONNECT;
  static inline bool TYPE_IsValid(int value) {
    return LogicServerRegiste_TYPE_IsValid(value);
  }
  static const TYPE TYPE_MIN =
    LogicServerRegiste_TYPE_TYPE_MIN;
  static const TYPE TYPE_MAX =
    LogicServerRegiste_TYPE_TYPE_MAX;
  static const int TYPE_ARRAYSIZE =
    LogicServerRegiste_TYPE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TYPE_descriptor() {
    return LogicServerRegiste_TYPE_descriptor();
  }
  static inline const ::std::string& TYPE_Name(TYPE value) {
    return LogicServerRegiste_TYPE_Name(value);
  }
  static inline bool TYPE_Parse(const ::std::string& name,
      TYPE* value) {
    return LogicServerRegiste_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // required uint32 outer_port = 2;
  inline bool has_outer_port() const;
  inline void clear_outer_port();
  static const int kOuterPortFieldNumber = 2;
  inline ::google::protobuf::uint32 outer_port() const;
  inline void set_outer_port(::google::protobuf::uint32 value);

  // required string outer_ip = 3;
  inline bool has_outer_ip() const;
  inline void clear_outer_ip();
  static const int kOuterIpFieldNumber = 3;
  inline const ::std::string& outer_ip() const;
  inline void set_outer_ip(const ::std::string& value);
  inline void set_outer_ip(const char* value);
  inline void set_outer_ip(const char* value, size_t size);
  inline ::std::string* mutable_outer_ip();
  inline ::std::string* release_outer_ip();
  inline void set_allocated_outer_ip(::std::string* outer_ip);

  // required .ProtoBuf.LogicServerRegiste.TYPE type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::ProtoBuf::LogicServerRegiste_TYPE type() const;
  inline void set_type(::ProtoBuf::LogicServerRegiste_TYPE value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LogicServerRegiste)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_outer_port();
  inline void clear_has_outer_port();
  inline void set_has_outer_ip();
  inline void clear_has_outer_ip();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 outer_port_;
  ::std::string* outer_ip_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogicServerRegiste* default_instance_;
};
// -------------------------------------------------------------------

class LoginServerState : public ::google::protobuf::Message {
 public:
  LoginServerState();
  virtual ~LoginServerState();

  LoginServerState(const LoginServerState& from);

  inline LoginServerState& operator=(const LoginServerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginServerState& default_instance();

  void Swap(LoginServerState* other);

  // implements Message ----------------------------------------------

  LoginServerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginServerState& from);
  void MergeFrom(const LoginServerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LoginServerState)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LoginServerState* default_instance_;
};
// -------------------------------------------------------------------

class LogicServerState : public ::google::protobuf::Message {
 public:
  LogicServerState();
  virtual ~LogicServerState();

  LogicServerState(const LogicServerState& from);

  inline LogicServerState& operator=(const LogicServerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicServerState& default_instance();

  void Swap(LogicServerState* other);

  // implements Message ----------------------------------------------

  LogicServerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicServerState& from);
  void MergeFrom(const LogicServerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // required uint32 characterCount = 2;
  inline bool has_charactercount() const;
  inline void clear_charactercount();
  static const int kCharacterCountFieldNumber = 2;
  inline ::google::protobuf::uint32 charactercount() const;
  inline void set_charactercount(::google::protobuf::uint32 value);

  // required uint32 playerCount = 3;
  inline bool has_playercount() const;
  inline void clear_playercount();
  static const int kPlayerCountFieldNumber = 3;
  inline ::google::protobuf::uint32 playercount() const;
  inline void set_playercount(::google::protobuf::uint32 value);

  // required uint32 enterAccountCount = 4;
  inline bool has_enteraccountcount() const;
  inline void clear_enteraccountcount();
  static const int kEnterAccountCountFieldNumber = 4;
  inline ::google::protobuf::uint32 enteraccountcount() const;
  inline void set_enteraccountcount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LogicServerState)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_charactercount();
  inline void clear_has_charactercount();
  inline void set_has_playercount();
  inline void clear_has_playercount();
  inline void set_has_enteraccountcount();
  inline void clear_has_enteraccountcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 charactercount_;
  ::google::protobuf::uint32 playercount_;
  ::google::protobuf::uint32 enteraccountcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogicServerState* default_instance_;
};
// -------------------------------------------------------------------

class AccountLoginCheckReq : public ::google::protobuf::Message {
 public:
  AccountLoginCheckReq();
  virtual ~AccountLoginCheckReq();

  AccountLoginCheckReq(const AccountLoginCheckReq& from);

  inline AccountLoginCheckReq& operator=(const AccountLoginCheckReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLoginCheckReq& default_instance();

  void Swap(AccountLoginCheckReq* other);

  // implements Message ----------------------------------------------

  AccountLoginCheckReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountLoginCheckReq& from);
  void MergeFrom(const AccountLoginCheckReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string channel_user_id = 1;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 1;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // required uint32 session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.AccountLoginCheckReq)
 private:
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_user_id_;
  ::google::protobuf::uint32 session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static AccountLoginCheckReq* default_instance_;
};
// -------------------------------------------------------------------

class AccountLoginCheckRsp : public ::google::protobuf::Message {
 public:
  AccountLoginCheckRsp();
  virtual ~AccountLoginCheckRsp();

  AccountLoginCheckRsp(const AccountLoginCheckRsp& from);

  inline AccountLoginCheckRsp& operator=(const AccountLoginCheckRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLoginCheckRsp& default_instance();

  void Swap(AccountLoginCheckRsp* other);

  // implements Message ----------------------------------------------

  AccountLoginCheckRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountLoginCheckRsp& from);
  void MergeFrom(const AccountLoginCheckRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string channel_user_id = 1;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 1;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // required uint32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required string logic_ip = 3;
  inline bool has_logic_ip() const;
  inline void clear_logic_ip();
  static const int kLogicIpFieldNumber = 3;
  inline const ::std::string& logic_ip() const;
  inline void set_logic_ip(const ::std::string& value);
  inline void set_logic_ip(const char* value);
  inline void set_logic_ip(const char* value, size_t size);
  inline ::std::string* mutable_logic_ip();
  inline ::std::string* release_logic_ip();
  inline void set_allocated_logic_ip(::std::string* logic_ip);

  // required uint32 logic_port = 4;
  inline bool has_logic_port() const;
  inline void clear_logic_port();
  static const int kLogicPortFieldNumber = 4;
  inline ::google::protobuf::uint32 logic_port() const;
  inline void set_logic_port(::google::protobuf::uint32 value);

  // required uint64 logic_token = 5;
  inline bool has_logic_token() const;
  inline void clear_logic_token();
  static const int kLogicTokenFieldNumber = 5;
  inline ::google::protobuf::uint64 logic_token() const;
  inline void set_logic_token(::google::protobuf::uint64 value);

  // required uint32 session_id = 6;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 6;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.AccountLoginCheckRsp)
 private:
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_logic_ip();
  inline void clear_has_logic_ip();
  inline void set_has_logic_port();
  inline void clear_has_logic_port();
  inline void set_has_logic_token();
  inline void clear_has_logic_token();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_user_id_;
  ::std::string* logic_ip_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 logic_port_;
  ::google::protobuf::uint64 logic_token_;
  ::google::protobuf::uint32 session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static AccountLoginCheckRsp* default_instance_;
};
// -------------------------------------------------------------------

class AccountLogoutNotify : public ::google::protobuf::Message {
 public:
  AccountLogoutNotify();
  virtual ~AccountLogoutNotify();

  AccountLogoutNotify(const AccountLogoutNotify& from);

  inline AccountLogoutNotify& operator=(const AccountLogoutNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLogoutNotify& default_instance();

  void Swap(AccountLogoutNotify* other);

  // implements Message ----------------------------------------------

  AccountLogoutNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountLogoutNotify& from);
  void MergeFrom(const AccountLogoutNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string channel_user_id = 1;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 1;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // @@protoc_insertion_point(class_scope:ProtoBuf.AccountLogoutNotify)
 private:
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static AccountLogoutNotify* default_instance_;
};
// -------------------------------------------------------------------

class LogicCheckTokenReq : public ::google::protobuf::Message {
 public:
  LogicCheckTokenReq();
  virtual ~LogicCheckTokenReq();

  LogicCheckTokenReq(const LogicCheckTokenReq& from);

  inline LogicCheckTokenReq& operator=(const LogicCheckTokenReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicCheckTokenReq& default_instance();

  void Swap(LogicCheckTokenReq* other);

  // implements Message ----------------------------------------------

  LogicCheckTokenReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicCheckTokenReq& from);
  void MergeFrom(const LogicCheckTokenReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string channel_user_id = 1;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 1;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // required uint64 logic_token = 2;
  inline bool has_logic_token() const;
  inline void clear_logic_token();
  static const int kLogicTokenFieldNumber = 2;
  inline ::google::protobuf::uint64 logic_token() const;
  inline void set_logic_token(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LogicCheckTokenReq)
 private:
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_logic_token();
  inline void clear_has_logic_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_user_id_;
  ::google::protobuf::uint64 logic_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogicCheckTokenReq* default_instance_;
};
// -------------------------------------------------------------------

class LogicCheckTokenRsp : public ::google::protobuf::Message {
 public:
  LogicCheckTokenRsp();
  virtual ~LogicCheckTokenRsp();

  LogicCheckTokenRsp(const LogicCheckTokenRsp& from);

  inline LogicCheckTokenRsp& operator=(const LogicCheckTokenRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicCheckTokenRsp& default_instance();

  void Swap(LogicCheckTokenRsp* other);

  // implements Message ----------------------------------------------

  LogicCheckTokenRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicCheckTokenRsp& from);
  void MergeFrom(const LogicCheckTokenRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 retcode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);

  // required string channel_user_id = 2;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 2;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LogicCheckTokenRsp)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_user_id_;
  ::google::protobuf::int32 retcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogicCheckTokenRsp* default_instance_;
};
// -------------------------------------------------------------------

class KickChannelUserNotify : public ::google::protobuf::Message {
 public:
  KickChannelUserNotify();
  virtual ~KickChannelUserNotify();

  KickChannelUserNotify(const KickChannelUserNotify& from);

  inline KickChannelUserNotify& operator=(const KickChannelUserNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KickChannelUserNotify& default_instance();

  void Swap(KickChannelUserNotify* other);

  // implements Message ----------------------------------------------

  KickChannelUserNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KickChannelUserNotify& from);
  void MergeFrom(const KickChannelUserNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string channel_user_id = 1;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 1;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // required uint32 charID = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIDFieldNumber = 2;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.KickChannelUserNotify)
 private:
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_user_id_;
  ::google::protobuf::uint32 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static KickChannelUserNotify* default_instance_;
};
// -------------------------------------------------------------------

class CenterAccountLogoutNotify : public ::google::protobuf::Message {
 public:
  CenterAccountLogoutNotify();
  virtual ~CenterAccountLogoutNotify();

  CenterAccountLogoutNotify(const CenterAccountLogoutNotify& from);

  inline CenterAccountLogoutNotify& operator=(const CenterAccountLogoutNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CenterAccountLogoutNotify& default_instance();

  void Swap(CenterAccountLogoutNotify* other);

  // implements Message ----------------------------------------------

  CenterAccountLogoutNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CenterAccountLogoutNotify& from);
  void MergeFrom(const CenterAccountLogoutNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CenterAccountLogoutNotify_TYPE TYPE;
  static const TYPE TOKEN_EXPIRED = CenterAccountLogoutNotify_TYPE_TOKEN_EXPIRED;
  static const TYPE CHARACTER_LOGOUT = CenterAccountLogoutNotify_TYPE_CHARACTER_LOGOUT;
  static inline bool TYPE_IsValid(int value) {
    return CenterAccountLogoutNotify_TYPE_IsValid(value);
  }
  static const TYPE TYPE_MIN =
    CenterAccountLogoutNotify_TYPE_TYPE_MIN;
  static const TYPE TYPE_MAX =
    CenterAccountLogoutNotify_TYPE_TYPE_MAX;
  static const int TYPE_ARRAYSIZE =
    CenterAccountLogoutNotify_TYPE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TYPE_descriptor() {
    return CenterAccountLogoutNotify_TYPE_descriptor();
  }
  static inline const ::std::string& TYPE_Name(TYPE value) {
    return CenterAccountLogoutNotify_TYPE_Name(value);
  }
  static inline bool TYPE_Parse(const ::std::string& name,
      TYPE* value) {
    return CenterAccountLogoutNotify_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ProtoBuf.CenterAccountLogoutNotify.TYPE type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ProtoBuf::CenterAccountLogoutNotify_TYPE type() const;
  inline void set_type(::ProtoBuf::CenterAccountLogoutNotify_TYPE value);

  // required string channel_user_id = 2;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 2;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // @@protoc_insertion_point(class_scope:ProtoBuf.CenterAccountLogoutNotify)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_user_id_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static CenterAccountLogoutNotify* default_instance_;
};
// -------------------------------------------------------------------

class ReconnectCheckRequest : public ::google::protobuf::Message {
 public:
  ReconnectCheckRequest();
  virtual ~ReconnectCheckRequest();

  ReconnectCheckRequest(const ReconnectCheckRequest& from);

  inline ReconnectCheckRequest& operator=(const ReconnectCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReconnectCheckRequest& default_instance();

  void Swap(ReconnectCheckRequest* other);

  // implements Message ----------------------------------------------

  ReconnectCheckRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReconnectCheckRequest& from);
  void MergeFrom(const ReconnectCheckRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 charId = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // required string channel_user_id = 2;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 2;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // required uint32 accountIndex = 3;
  inline bool has_accountindex() const;
  inline void clear_accountindex();
  static const int kAccountIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 accountindex() const;
  inline void set_accountindex(::google::protobuf::uint32 value);

  // required uint64 token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // required string channelId = 5;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIdFieldNumber = 5;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  inline void set_allocated_channelid(::std::string* channelid);

  // required string userId = 6;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 6;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // @@protoc_insertion_point(class_scope:ProtoBuf.ReconnectCheckRequest)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_accountindex();
  inline void clear_has_accountindex();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_user_id_;
  ::google::protobuf::uint32 charid_;
  ::google::protobuf::uint32 accountindex_;
  ::google::protobuf::uint64 token_;
  ::std::string* channelid_;
  ::std::string* userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static ReconnectCheckRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReconnectCheckResponse : public ::google::protobuf::Message {
 public:
  ReconnectCheckResponse();
  virtual ~ReconnectCheckResponse();

  ReconnectCheckResponse(const ReconnectCheckResponse& from);

  inline ReconnectCheckResponse& operator=(const ReconnectCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReconnectCheckResponse& default_instance();

  void Swap(ReconnectCheckResponse* other);

  // implements Message ----------------------------------------------

  ReconnectCheckResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReconnectCheckResponse& from);
  void MergeFrom(const ReconnectCheckResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 retCode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 retcode() const;
  inline void set_retcode(::google::protobuf::uint32 value);

  // required uint32 charId = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // required string channel_user_id = 3;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 3;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // required uint32 accountIndex = 4;
  inline bool has_accountindex() const;
  inline void clear_accountindex();
  static const int kAccountIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 accountindex() const;
  inline void set_accountindex(::google::protobuf::uint32 value);

  // required uint64 token = 5;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 5;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // required string channelId = 6;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIdFieldNumber = 6;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  inline void set_allocated_channelid(::std::string* channelid);

  // required string userId = 7;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 7;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // @@protoc_insertion_point(class_scope:ProtoBuf.ReconnectCheckResponse)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_accountindex();
  inline void clear_has_accountindex();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 retcode_;
  ::google::protobuf::uint32 charid_;
  ::std::string* channel_user_id_;
  ::google::protobuf::uint64 token_;
  ::std::string* channelid_;
  ::std::string* userid_;
  ::google::protobuf::uint32 accountindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static ReconnectCheckResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogicServerAddressReq : public ::google::protobuf::Message {
 public:
  LogicServerAddressReq();
  virtual ~LogicServerAddressReq();

  LogicServerAddressReq(const LogicServerAddressReq& from);

  inline LogicServerAddressReq& operator=(const LogicServerAddressReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicServerAddressReq& default_instance();

  void Swap(LogicServerAddressReq* other);

  // implements Message ----------------------------------------------

  LogicServerAddressReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicServerAddressReq& from);
  void MergeFrom(const LogicServerAddressReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string app_guid = 1;
  inline bool has_app_guid() const;
  inline void clear_app_guid();
  static const int kAppGuidFieldNumber = 1;
  inline const ::std::string& app_guid() const;
  inline void set_app_guid(const ::std::string& value);
  inline void set_app_guid(const char* value);
  inline void set_app_guid(const char* value, size_t size);
  inline ::std::string* mutable_app_guid();
  inline ::std::string* release_app_guid();
  inline void set_allocated_app_guid(::std::string* app_guid);

  // required string channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // required string user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LogicServerAddressReq)
 private:
  inline void set_has_app_guid();
  inline void clear_has_app_guid();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* app_guid_;
  ::std::string* channel_id_;
  ::std::string* user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogicServerAddressReq* default_instance_;
};
// -------------------------------------------------------------------

class LoginLogicRequest : public ::google::protobuf::Message {
 public:
  LoginLogicRequest();
  virtual ~LoginLogicRequest();

  LoginLogicRequest(const LoginLogicRequest& from);

  inline LoginLogicRequest& operator=(const LoginLogicRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginLogicRequest& default_instance();

  void Swap(LoginLogicRequest* other);

  // implements Message ----------------------------------------------

  LoginLogicRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginLogicRequest& from);
  void MergeFrom(const LoginLogicRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 connect_index = 1;
  inline bool has_connect_index() const;
  inline void clear_connect_index();
  static const int kConnectIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 connect_index() const;
  inline void set_connect_index(::google::protobuf::uint32 value);

  // required string channel_user_id = 2;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 2;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // required uint64 token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // required uint32 group_id = 4;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 4;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LoginLogicRequest)
 private:
  inline void set_has_connect_index();
  inline void clear_has_connect_index();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_user_id_;
  ::google::protobuf::uint32 connect_index_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint64 token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LoginLogicRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginLogicResponse_SwitchServerParam : public ::google::protobuf::Message {
 public:
  LoginLogicResponse_SwitchServerParam();
  virtual ~LoginLogicResponse_SwitchServerParam();

  LoginLogicResponse_SwitchServerParam(const LoginLogicResponse_SwitchServerParam& from);

  inline LoginLogicResponse_SwitchServerParam& operator=(const LoginLogicResponse_SwitchServerParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginLogicResponse_SwitchServerParam& default_instance();

  void Swap(LoginLogicResponse_SwitchServerParam* other);

  // implements Message ----------------------------------------------

  LoginLogicResponse_SwitchServerParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginLogicResponse_SwitchServerParam& from);
  void MergeFrom(const LoginLogicResponse_SwitchServerParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_id = 1;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required uint32 source_scene_template_id = 2;
  inline bool has_source_scene_template_id() const;
  inline void clear_source_scene_template_id();
  static const int kSourceSceneTemplateIdFieldNumber = 2;
  inline ::google::protobuf::uint32 source_scene_template_id() const;
  inline void set_source_scene_template_id(::google::protobuf::uint32 value);

  // required float source_pose_x = 3;
  inline bool has_source_pose_x() const;
  inline void clear_source_pose_x();
  static const int kSourcePoseXFieldNumber = 3;
  inline float source_pose_x() const;
  inline void set_source_pose_x(float value);

  // required float source_pose_y = 4;
  inline bool has_source_pose_y() const;
  inline void clear_source_pose_y();
  static const int kSourcePoseYFieldNumber = 4;
  inline float source_pose_y() const;
  inline void set_source_pose_y(float value);

  // required uint32 dest_scene_template_id = 5;
  inline bool has_dest_scene_template_id() const;
  inline void clear_dest_scene_template_id();
  static const int kDestSceneTemplateIdFieldNumber = 5;
  inline ::google::protobuf::uint32 dest_scene_template_id() const;
  inline void set_dest_scene_template_id(::google::protobuf::uint32 value);

  // required uint32 dest_scene_instance_id = 6;
  inline bool has_dest_scene_instance_id() const;
  inline void clear_dest_scene_instance_id();
  static const int kDestSceneInstanceIdFieldNumber = 6;
  inline ::google::protobuf::uint32 dest_scene_instance_id() const;
  inline void set_dest_scene_instance_id(::google::protobuf::uint32 value);

  // required uint64 dest_scene_enter_key = 7;
  inline bool has_dest_scene_enter_key() const;
  inline void clear_dest_scene_enter_key();
  static const int kDestSceneEnterKeyFieldNumber = 7;
  inline ::google::protobuf::uint64 dest_scene_enter_key() const;
  inline void set_dest_scene_enter_key(::google::protobuf::uint64 value);

  // required float dest_scene_pos_x = 8;
  inline bool has_dest_scene_pos_x() const;
  inline void clear_dest_scene_pos_x();
  static const int kDestScenePosXFieldNumber = 8;
  inline float dest_scene_pos_x() const;
  inline void set_dest_scene_pos_x(float value);

  // required float dest_scene_pos_y = 9;
  inline bool has_dest_scene_pos_y() const;
  inline void clear_dest_scene_pos_y();
  static const int kDestScenePosYFieldNumber = 9;
  inline float dest_scene_pos_y() const;
  inline void set_dest_scene_pos_y(float value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LoginLogicResponse.SwitchServerParam)
 private:
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_source_scene_template_id();
  inline void clear_has_source_scene_template_id();
  inline void set_has_source_pose_x();
  inline void clear_has_source_pose_x();
  inline void set_has_source_pose_y();
  inline void clear_has_source_pose_y();
  inline void set_has_dest_scene_template_id();
  inline void clear_has_dest_scene_template_id();
  inline void set_has_dest_scene_instance_id();
  inline void clear_has_dest_scene_instance_id();
  inline void set_has_dest_scene_enter_key();
  inline void clear_has_dest_scene_enter_key();
  inline void set_has_dest_scene_pos_x();
  inline void clear_has_dest_scene_pos_x();
  inline void set_has_dest_scene_pos_y();
  inline void clear_has_dest_scene_pos_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 character_id_;
  ::google::protobuf::uint32 source_scene_template_id_;
  float source_pose_x_;
  float source_pose_y_;
  ::google::protobuf::uint32 dest_scene_template_id_;
  ::google::protobuf::uint32 dest_scene_instance_id_;
  ::google::protobuf::uint64 dest_scene_enter_key_;
  float dest_scene_pos_x_;
  float dest_scene_pos_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LoginLogicResponse_SwitchServerParam* default_instance_;
};
// -------------------------------------------------------------------

class LoginLogicResponse : public ::google::protobuf::Message {
 public:
  LoginLogicResponse();
  virtual ~LoginLogicResponse();

  LoginLogicResponse(const LoginLogicResponse& from);

  inline LoginLogicResponse& operator=(const LoginLogicResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginLogicResponse& default_instance();

  void Swap(LoginLogicResponse* other);

  // implements Message ----------------------------------------------

  LoginLogicResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginLogicResponse& from);
  void MergeFrom(const LoginLogicResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoginLogicResponse_SwitchServerParam SwitchServerParam;

  typedef LoginLogicResponse_RESULT RESULT;
  static const RESULT LOGIN_LOGIC_SUCESS = LoginLogicResponse_RESULT_LOGIN_LOGIC_SUCESS;
  static const RESULT LOGIN_LOGIC_FAIL = LoginLogicResponse_RESULT_LOGIN_LOGIC_FAIL;
  static inline bool RESULT_IsValid(int value) {
    return LoginLogicResponse_RESULT_IsValid(value);
  }
  static const RESULT RESULT_MIN =
    LoginLogicResponse_RESULT_RESULT_MIN;
  static const RESULT RESULT_MAX =
    LoginLogicResponse_RESULT_RESULT_MAX;
  static const int RESULT_ARRAYSIZE =
    LoginLogicResponse_RESULT_RESULT_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RESULT_descriptor() {
    return LoginLogicResponse_RESULT_descriptor();
  }
  static inline const ::std::string& RESULT_Name(RESULT value) {
    return LoginLogicResponse_RESULT_Name(value);
  }
  static inline bool RESULT_Parse(const ::std::string& name,
      RESULT* value) {
    return LoginLogicResponse_RESULT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 connect_index = 1;
  inline bool has_connect_index() const;
  inline void clear_connect_index();
  static const int kConnectIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 connect_index() const;
  inline void set_connect_index(::google::protobuf::uint32 value);

  // required .ProtoBuf.LoginLogicResponse.RESULT result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::ProtoBuf::LoginLogicResponse_RESULT result() const;
  inline void set_result(::ProtoBuf::LoginLogicResponse_RESULT value);

  // optional string channel_user_id = 3;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 3;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // optional uint32 group_id = 4;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 4;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // optional uint32 switch_server_flag = 6;
  inline bool has_switch_server_flag() const;
  inline void clear_switch_server_flag();
  static const int kSwitchServerFlagFieldNumber = 6;
  inline ::google::protobuf::uint32 switch_server_flag() const;
  inline void set_switch_server_flag(::google::protobuf::uint32 value);

  // optional .ProtoBuf.LoginLogicResponse.SwitchServerParam switch_server_param = 7;
  inline bool has_switch_server_param() const;
  inline void clear_switch_server_param();
  static const int kSwitchServerParamFieldNumber = 7;
  inline const ::ProtoBuf::LoginLogicResponse_SwitchServerParam& switch_server_param() const;
  inline ::ProtoBuf::LoginLogicResponse_SwitchServerParam* mutable_switch_server_param();
  inline ::ProtoBuf::LoginLogicResponse_SwitchServerParam* release_switch_server_param();
  inline void set_allocated_switch_server_param(::ProtoBuf::LoginLogicResponse_SwitchServerParam* switch_server_param);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LoginLogicResponse)
 private:
  inline void set_has_connect_index();
  inline void clear_has_connect_index();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_switch_server_flag();
  inline void clear_has_switch_server_flag();
  inline void set_has_switch_server_param();
  inline void clear_has_switch_server_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 connect_index_;
  int result_;
  ::std::string* channel_user_id_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 switch_server_flag_;
  ::ProtoBuf::LoginLogicResponse_SwitchServerParam* switch_server_param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LoginLogicResponse* default_instance_;
};
// -------------------------------------------------------------------

class SwitchServerBeginNotify : public ::google::protobuf::Message {
 public:
  SwitchServerBeginNotify();
  virtual ~SwitchServerBeginNotify();

  SwitchServerBeginNotify(const SwitchServerBeginNotify& from);

  inline SwitchServerBeginNotify& operator=(const SwitchServerBeginNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchServerBeginNotify& default_instance();

  void Swap(SwitchServerBeginNotify* other);

  // implements Message ----------------------------------------------

  SwitchServerBeginNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwitchServerBeginNotify& from);
  void MergeFrom(const SwitchServerBeginNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // required string user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // required uint32 character_id = 3;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 3;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required uint32 source_scene_template_id = 4;
  inline bool has_source_scene_template_id() const;
  inline void clear_source_scene_template_id();
  static const int kSourceSceneTemplateIdFieldNumber = 4;
  inline ::google::protobuf::uint32 source_scene_template_id() const;
  inline void set_source_scene_template_id(::google::protobuf::uint32 value);

  // required float source_pose_x = 5;
  inline bool has_source_pose_x() const;
  inline void clear_source_pose_x();
  static const int kSourcePoseXFieldNumber = 5;
  inline float source_pose_x() const;
  inline void set_source_pose_x(float value);

  // required float source_pose_y = 6;
  inline bool has_source_pose_y() const;
  inline void clear_source_pose_y();
  static const int kSourcePoseYFieldNumber = 6;
  inline float source_pose_y() const;
  inline void set_source_pose_y(float value);

  // required uint32 dest_logic_service_id = 7;
  inline bool has_dest_logic_service_id() const;
  inline void clear_dest_logic_service_id();
  static const int kDestLogicServiceIdFieldNumber = 7;
  inline ::google::protobuf::uint32 dest_logic_service_id() const;
  inline void set_dest_logic_service_id(::google::protobuf::uint32 value);

  // required uint32 dest_scene_template_id = 8;
  inline bool has_dest_scene_template_id() const;
  inline void clear_dest_scene_template_id();
  static const int kDestSceneTemplateIdFieldNumber = 8;
  inline ::google::protobuf::uint32 dest_scene_template_id() const;
  inline void set_dest_scene_template_id(::google::protobuf::uint32 value);

  // required uint32 dest_scene_instance_id = 9;
  inline bool has_dest_scene_instance_id() const;
  inline void clear_dest_scene_instance_id();
  static const int kDestSceneInstanceIdFieldNumber = 9;
  inline ::google::protobuf::uint32 dest_scene_instance_id() const;
  inline void set_dest_scene_instance_id(::google::protobuf::uint32 value);

  // required uint64 dest_scene_enter_key = 10;
  inline bool has_dest_scene_enter_key() const;
  inline void clear_dest_scene_enter_key();
  static const int kDestSceneEnterKeyFieldNumber = 10;
  inline ::google::protobuf::uint64 dest_scene_enter_key() const;
  inline void set_dest_scene_enter_key(::google::protobuf::uint64 value);

  // required float dest_scene_pos_x = 11;
  inline bool has_dest_scene_pos_x() const;
  inline void clear_dest_scene_pos_x();
  static const int kDestScenePosXFieldNumber = 11;
  inline float dest_scene_pos_x() const;
  inline void set_dest_scene_pos_x(float value);

  // required float dest_scene_pos_y = 12;
  inline bool has_dest_scene_pos_y() const;
  inline void clear_dest_scene_pos_y();
  static const int kDestScenePosYFieldNumber = 12;
  inline float dest_scene_pos_y() const;
  inline void set_dest_scene_pos_y(float value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.SwitchServerBeginNotify)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_source_scene_template_id();
  inline void clear_has_source_scene_template_id();
  inline void set_has_source_pose_x();
  inline void clear_has_source_pose_x();
  inline void set_has_source_pose_y();
  inline void clear_has_source_pose_y();
  inline void set_has_dest_logic_service_id();
  inline void clear_has_dest_logic_service_id();
  inline void set_has_dest_scene_template_id();
  inline void clear_has_dest_scene_template_id();
  inline void set_has_dest_scene_instance_id();
  inline void clear_has_dest_scene_instance_id();
  inline void set_has_dest_scene_enter_key();
  inline void clear_has_dest_scene_enter_key();
  inline void set_has_dest_scene_pos_x();
  inline void clear_has_dest_scene_pos_x();
  inline void set_has_dest_scene_pos_y();
  inline void clear_has_dest_scene_pos_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_id_;
  ::std::string* user_id_;
  ::google::protobuf::uint32 character_id_;
  ::google::protobuf::uint32 source_scene_template_id_;
  float source_pose_x_;
  float source_pose_y_;
  ::google::protobuf::uint32 dest_logic_service_id_;
  ::google::protobuf::uint32 dest_scene_template_id_;
  ::google::protobuf::uint64 dest_scene_enter_key_;
  ::google::protobuf::uint32 dest_scene_instance_id_;
  float dest_scene_pos_x_;
  float dest_scene_pos_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static SwitchServerBeginNotify* default_instance_;
};
// -------------------------------------------------------------------

class BroadcastToLogicServer : public ::google::protobuf::Message {
 public:
  BroadcastToLogicServer();
  virtual ~BroadcastToLogicServer();

  BroadcastToLogicServer(const BroadcastToLogicServer& from);

  inline BroadcastToLogicServer& operator=(const BroadcastToLogicServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastToLogicServer& default_instance();

  void Swap(BroadcastToLogicServer* other);

  // implements Message ----------------------------------------------

  BroadcastToLogicServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadcastToLogicServer& from);
  void MergeFrom(const BroadcastToLogicServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 groupId = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 groupid() const;
  inline void set_groupid(::google::protobuf::uint32 value);

  // required bytes msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:ProtoBuf.BroadcastToLogicServer)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  ::google::protobuf::uint32 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static BroadcastToLogicServer* default_instance_;
};
// -------------------------------------------------------------------

class LogicToCenterCreateChar : public ::google::protobuf::Message {
 public:
  LogicToCenterCreateChar();
  virtual ~LogicToCenterCreateChar();

  LogicToCenterCreateChar(const LogicToCenterCreateChar& from);

  inline LogicToCenterCreateChar& operator=(const LogicToCenterCreateChar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicToCenterCreateChar& default_instance();

  void Swap(LogicToCenterCreateChar* other);

  // implements Message ----------------------------------------------

  LogicToCenterCreateChar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicToCenterCreateChar& from);
  void MergeFrom(const LogicToCenterCreateChar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 charID = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIDFieldNumber = 1;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // required .ProtoBuf.CharacterDBBaseInfo base = 2;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 2;
  inline const ::ProtoBuf::CharacterDBBaseInfo& base() const;
  inline ::ProtoBuf::CharacterDBBaseInfo* mutable_base();
  inline ::ProtoBuf::CharacterDBBaseInfo* release_base();
  inline void set_allocated_base(::ProtoBuf::CharacterDBBaseInfo* base);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LogicToCenterCreateChar)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_base();
  inline void clear_has_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoBuf::CharacterDBBaseInfo* base_;
  ::google::protobuf::uint32 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogicToCenterCreateChar* default_instance_;
};
// -------------------------------------------------------------------

class LogicToCenterDelChar : public ::google::protobuf::Message {
 public:
  LogicToCenterDelChar();
  virtual ~LogicToCenterDelChar();

  LogicToCenterDelChar(const LogicToCenterDelChar& from);

  inline LogicToCenterDelChar& operator=(const LogicToCenterDelChar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicToCenterDelChar& default_instance();

  void Swap(LogicToCenterDelChar* other);

  // implements Message ----------------------------------------------

  LogicToCenterDelChar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicToCenterDelChar& from);
  void MergeFrom(const LogicToCenterDelChar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 charID = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIDFieldNumber = 1;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // required string channel_user_id = 2;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 2;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LogicToCenterDelChar)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_user_id_;
  ::google::protobuf::uint32 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogicToCenterDelChar* default_instance_;
};
// -------------------------------------------------------------------

class LogicToCenterCharSync : public ::google::protobuf::Message {
 public:
  LogicToCenterCharSync();
  virtual ~LogicToCenterCharSync();

  LogicToCenterCharSync(const LogicToCenterCharSync& from);

  inline LogicToCenterCharSync& operator=(const LogicToCenterCharSync& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicToCenterCharSync& default_instance();

  void Swap(LogicToCenterCharSync* other);

  // implements Message ----------------------------------------------

  LogicToCenterCharSync* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicToCenterCharSync& from);
  void MergeFrom(const LogicToCenterCharSync& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 charID = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIDFieldNumber = 1;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // repeated .ProtoBuf.CharSyncAttr attrlist = 2;
  inline int attrlist_size() const;
  inline void clear_attrlist();
  static const int kAttrlistFieldNumber = 2;
  inline const ::ProtoBuf::CharSyncAttr& attrlist(int index) const;
  inline ::ProtoBuf::CharSyncAttr* mutable_attrlist(int index);
  inline ::ProtoBuf::CharSyncAttr* add_attrlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::CharSyncAttr >&
      attrlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::CharSyncAttr >*
      mutable_attrlist();

  // repeated .ProtoBuf.ItemProtoInfo equip = 3;
  inline int equip_size() const;
  inline void clear_equip();
  static const int kEquipFieldNumber = 3;
  inline const ::ProtoBuf::ItemProtoInfo& equip(int index) const;
  inline ::ProtoBuf::ItemProtoInfo* mutable_equip(int index);
  inline ::ProtoBuf::ItemProtoInfo* add_equip();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::ItemProtoInfo >&
      equip() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::ItemProtoInfo >*
      mutable_equip();

  // optional int32 all_equip = 4;
  inline bool has_all_equip() const;
  inline void clear_all_equip();
  static const int kAllEquipFieldNumber = 4;
  inline ::google::protobuf::int32 all_equip() const;
  inline void set_all_equip(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LogicToCenterCharSync)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_all_equip();
  inline void clear_has_all_equip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::CharSyncAttr > attrlist_;
  ::google::protobuf::uint32 charid_;
  ::google::protobuf::int32 all_equip_;
  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::ItemProtoInfo > equip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogicToCenterCharSync* default_instance_;
};
// -------------------------------------------------------------------

class EnterLogicRequest : public ::google::protobuf::Message {
 public:
  EnterLogicRequest();
  virtual ~EnterLogicRequest();

  EnterLogicRequest(const EnterLogicRequest& from);

  inline EnterLogicRequest& operator=(const EnterLogicRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterLogicRequest& default_instance();

  void Swap(EnterLogicRequest* other);

  // implements Message ----------------------------------------------

  EnterLogicRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterLogicRequest& from);
  void MergeFrom(const EnterLogicRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_id = 1;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required string channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // required string user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // required uint64 token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // required string channel_user_id = 5;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 5;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // required .ProtoBuf.CharacterDBSimpleInfo charSimpleInfo = 6;
  inline bool has_charsimpleinfo() const;
  inline void clear_charsimpleinfo();
  static const int kCharSimpleInfoFieldNumber = 6;
  inline const ::ProtoBuf::CharacterDBSimpleInfo& charsimpleinfo() const;
  inline ::ProtoBuf::CharacterDBSimpleInfo* mutable_charsimpleinfo();
  inline ::ProtoBuf::CharacterDBSimpleInfo* release_charsimpleinfo();
  inline void set_allocated_charsimpleinfo(::ProtoBuf::CharacterDBSimpleInfo* charsimpleinfo);

  // optional int32 map_id = 7;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 7;
  inline ::google::protobuf::int32 map_id() const;
  inline void set_map_id(::google::protobuf::int32 value);

  // optional int32 scene_id = 8;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 8;
  inline ::google::protobuf::int32 scene_id() const;
  inline void set_scene_id(::google::protobuf::int32 value);

  // repeated .ProtoBuf.ItemProtoInfo equip = 9;
  inline int equip_size() const;
  inline void clear_equip();
  static const int kEquipFieldNumber = 9;
  inline const ::ProtoBuf::ItemProtoInfo& equip(int index) const;
  inline ::ProtoBuf::ItemProtoInfo* mutable_equip(int index);
  inline ::ProtoBuf::ItemProtoInfo* add_equip();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::ItemProtoInfo >&
      equip() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::ItemProtoInfo >*
      mutable_equip();

  // optional .ProtoBuf.CharacterDBAttrDetailInfo attr = 10;
  inline bool has_attr() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 10;
  inline const ::ProtoBuf::CharacterDBAttrDetailInfo& attr() const;
  inline ::ProtoBuf::CharacterDBAttrDetailInfo* mutable_attr();
  inline ::ProtoBuf::CharacterDBAttrDetailInfo* release_attr();
  inline void set_allocated_attr(::ProtoBuf::CharacterDBAttrDetailInfo* attr);

  // @@protoc_insertion_point(class_scope:ProtoBuf.EnterLogicRequest)
 private:
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_charsimpleinfo();
  inline void clear_has_charsimpleinfo();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_attr();
  inline void clear_has_attr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_id_;
  ::std::string* user_id_;
  ::google::protobuf::uint64 token_;
  ::google::protobuf::uint32 character_id_;
  ::google::protobuf::int32 map_id_;
  ::std::string* channel_user_id_;
  ::ProtoBuf::CharacterDBSimpleInfo* charsimpleinfo_;
  ::google::protobuf::RepeatedPtrField< ::ProtoBuf::ItemProtoInfo > equip_;
  ::ProtoBuf::CharacterDBAttrDetailInfo* attr_;
  ::google::protobuf::int32 scene_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static EnterLogicRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogoutLogicRequest : public ::google::protobuf::Message {
 public:
  LogoutLogicRequest();
  virtual ~LogoutLogicRequest();

  LogoutLogicRequest(const LogoutLogicRequest& from);

  inline LogoutLogicRequest& operator=(const LogoutLogicRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutLogicRequest& default_instance();

  void Swap(LogoutLogicRequest* other);

  // implements Message ----------------------------------------------

  LogoutLogicRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutLogicRequest& from);
  void MergeFrom(const LogoutLogicRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LogoutLogicRequest_FLAG FLAG;
  static const FLAG LOGOUT_FLAG_GAMING = LogoutLogicRequest_FLAG_LOGOUT_FLAG_GAMING;
  static const FLAG LOGOUT_FLAG_KICKOUT = LogoutLogicRequest_FLAG_LOGOUT_FLAG_KICKOUT;
  static const FLAG LOGOUT_FLAG_LOGIN_BREAK = LogoutLogicRequest_FLAG_LOGOUT_FLAG_LOGIN_BREAK;
  static const FLAG LOGOUT_FLAG_SWITCH_SERVER = LogoutLogicRequest_FLAG_LOGOUT_FLAG_SWITCH_SERVER;
  static inline bool FLAG_IsValid(int value) {
    return LogoutLogicRequest_FLAG_IsValid(value);
  }
  static const FLAG FLAG_MIN =
    LogoutLogicRequest_FLAG_FLAG_MIN;
  static const FLAG FLAG_MAX =
    LogoutLogicRequest_FLAG_FLAG_MAX;
  static const int FLAG_ARRAYSIZE =
    LogoutLogicRequest_FLAG_FLAG_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FLAG_descriptor() {
    return LogoutLogicRequest_FLAG_descriptor();
  }
  static inline const ::std::string& FLAG_Name(FLAG value) {
    return LogoutLogicRequest_FLAG_Name(value);
  }
  static inline bool FLAG_Parse(const ::std::string& name,
      FLAG* value) {
    return LogoutLogicRequest_FLAG_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ProtoBuf.LogoutLogicRequest.FLAG flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline ::ProtoBuf::LogoutLogicRequest_FLAG flag() const;
  inline void set_flag(::ProtoBuf::LogoutLogicRequest_FLAG value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required string channel_user_id = 3;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 3;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // required uint64 token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.LogoutLogicRequest)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int flag_;
  ::google::protobuf::uint32 character_id_;
  ::std::string* channel_user_id_;
  ::google::protobuf::uint64 token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogoutLogicRequest* default_instance_;
};
// -------------------------------------------------------------------

class AllocLogicNodeRequest : public ::google::protobuf::Message {
 public:
  AllocLogicNodeRequest();
  virtual ~AllocLogicNodeRequest();

  AllocLogicNodeRequest(const AllocLogicNodeRequest& from);

  inline AllocLogicNodeRequest& operator=(const AllocLogicNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllocLogicNodeRequest& default_instance();

  void Swap(AllocLogicNodeRequest* other);

  // implements Message ----------------------------------------------

  AllocLogicNodeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllocLogicNodeRequest& from);
  void MergeFrom(const AllocLogicNodeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_id = 1;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required string channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // required string user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // required string channel_user_id = 5;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 5;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // @@protoc_insertion_point(class_scope:ProtoBuf.AllocLogicNodeRequest)
 private:
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channel_id_;
  ::std::string* user_id_;
  ::std::string* channel_user_id_;
  ::google::protobuf::uint32 character_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static AllocLogicNodeRequest* default_instance_;
};
// -------------------------------------------------------------------

class AllocLogicNodeResponse : public ::google::protobuf::Message {
 public:
  AllocLogicNodeResponse();
  virtual ~AllocLogicNodeResponse();

  AllocLogicNodeResponse(const AllocLogicNodeResponse& from);

  inline AllocLogicNodeResponse& operator=(const AllocLogicNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllocLogicNodeResponse& default_instance();

  void Swap(AllocLogicNodeResponse* other);

  // implements Message ----------------------------------------------

  AllocLogicNodeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllocLogicNodeResponse& from);
  void MergeFrom(const AllocLogicNodeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required string channel_id = 3;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 3;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // required string user_id = 4;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // required string channel_user_id = 5;
  inline bool has_channel_user_id() const;
  inline void clear_channel_user_id();
  static const int kChannelUserIdFieldNumber = 5;
  inline const ::std::string& channel_user_id() const;
  inline void set_channel_user_id(const ::std::string& value);
  inline void set_channel_user_id(const char* value);
  inline void set_channel_user_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_user_id();
  inline ::std::string* release_channel_user_id();
  inline void set_allocated_channel_user_id(::std::string* channel_user_id);

  // optional uint32 dst_scene_id = 6;
  inline bool has_dst_scene_id() const;
  inline void clear_dst_scene_id();
  static const int kDstSceneIdFieldNumber = 6;
  inline ::google::protobuf::uint32 dst_scene_id() const;
  inline void set_dst_scene_id(::google::protobuf::uint32 value);

  // optional uint32 dst_map_id = 7;
  inline bool has_dst_map_id() const;
  inline void clear_dst_map_id();
  static const int kDstMapIdFieldNumber = 7;
  inline ::google::protobuf::uint32 dst_map_id() const;
  inline void set_dst_map_id(::google::protobuf::uint32 value);

  // optional string logic_ip = 8;
  inline bool has_logic_ip() const;
  inline void clear_logic_ip();
  static const int kLogicIpFieldNumber = 8;
  inline const ::std::string& logic_ip() const;
  inline void set_logic_ip(const ::std::string& value);
  inline void set_logic_ip(const char* value);
  inline void set_logic_ip(const char* value, size_t size);
  inline ::std::string* mutable_logic_ip();
  inline ::std::string* release_logic_ip();
  inline void set_allocated_logic_ip(::std::string* logic_ip);

  // optional uint32 logic_port = 9;
  inline bool has_logic_port() const;
  inline void clear_logic_port();
  static const int kLogicPortFieldNumber = 9;
  inline ::google::protobuf::uint32 logic_port() const;
  inline void set_logic_port(::google::protobuf::uint32 value);

  // optional uint32 logic_token = 10;
  inline bool has_logic_token() const;
  inline void clear_logic_token();
  static const int kLogicTokenFieldNumber = 10;
  inline ::google::protobuf::uint32 logic_token() const;
  inline void set_logic_token(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.AllocLogicNodeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_channel_user_id();
  inline void clear_has_channel_user_id();
  inline void set_has_dst_scene_id();
  inline void clear_has_dst_scene_id();
  inline void set_has_dst_map_id();
  inline void clear_has_dst_map_id();
  inline void set_has_logic_ip();
  inline void clear_has_logic_ip();
  inline void set_has_logic_port();
  inline void clear_has_logic_port();
  inline void set_has_logic_token();
  inline void clear_has_logic_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::uint32 character_id_;
  ::std::string* channel_id_;
  ::std::string* user_id_;
  ::std::string* channel_user_id_;
  ::google::protobuf::uint32 dst_scene_id_;
  ::google::protobuf::uint32 dst_map_id_;
  ::std::string* logic_ip_;
  ::google::protobuf::uint32 logic_port_;
  ::google::protobuf::uint32 logic_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static AllocLogicNodeResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientNotifyToClient : public ::google::protobuf::Message {
 public:
  ClientNotifyToClient();
  virtual ~ClientNotifyToClient();

  ClientNotifyToClient(const ClientNotifyToClient& from);

  inline ClientNotifyToClient& operator=(const ClientNotifyToClient& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientNotifyToClient& default_instance();

  void Swap(ClientNotifyToClient* other);

  // implements Message ----------------------------------------------

  ClientNotifyToClient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientNotifyToClient& from);
  void MergeFrom(const ClientNotifyToClient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 charId = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // required uint32 event = 2;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 2;
  inline ::google::protobuf::uint32 event() const;
  inline void set_event(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.ClientNotifyToClient)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_event();
  inline void clear_has_event();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 charid_;
  ::google::protobuf::uint32 event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static ClientNotifyToClient* default_instance_;
};
// -------------------------------------------------------------------

class DBProxyAddrInfo : public ::google::protobuf::Message {
 public:
  DBProxyAddrInfo();
  virtual ~DBProxyAddrInfo();

  DBProxyAddrInfo(const DBProxyAddrInfo& from);

  inline DBProxyAddrInfo& operator=(const DBProxyAddrInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBProxyAddrInfo& default_instance();

  void Swap(DBProxyAddrInfo* other);

  // implements Message ----------------------------------------------

  DBProxyAddrInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBProxyAddrInfo& from);
  void MergeFrom(const DBProxyAddrInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 groupId = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 groupid() const;
  inline void set_groupid(::google::protobuf::uint32 value);

  // required uint32 serverId = 2;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 serverid() const;
  inline void set_serverid(::google::protobuf::uint32 value);

  // required uint32 Port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required string Ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:ProtoBuf.DBProxyAddrInfo)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 groupid_;
  ::google::protobuf::uint32 serverid_;
  ::std::string* ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static DBProxyAddrInfo* default_instance_;
};
// -------------------------------------------------------------------

class CenterRspSceneId : public ::google::protobuf::Message {
 public:
  CenterRspSceneId();
  virtual ~CenterRspSceneId();

  CenterRspSceneId(const CenterRspSceneId& from);

  inline CenterRspSceneId& operator=(const CenterRspSceneId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CenterRspSceneId& default_instance();

  void Swap(CenterRspSceneId* other);

  // implements Message ----------------------------------------------

  CenterRspSceneId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CenterRspSceneId& from);
  void MergeFrom(const CenterRspSceneId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 retCode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 retcode() const;
  inline void set_retcode(::google::protobuf::uint32 value);

  // optional uint32 dstSceneId = 2;
  inline bool has_dstsceneid() const;
  inline void clear_dstsceneid();
  static const int kDstSceneIdFieldNumber = 2;
  inline ::google::protobuf::uint32 dstsceneid() const;
  inline void set_dstsceneid(::google::protobuf::uint32 value);

  // optional .ProtoBuf.Vector3PB dstPos = 3;
  inline bool has_dstpos() const;
  inline void clear_dstpos();
  static const int kDstPosFieldNumber = 3;
  inline const ::ProtoBuf::Vector3PB& dstpos() const;
  inline ::ProtoBuf::Vector3PB* mutable_dstpos();
  inline ::ProtoBuf::Vector3PB* release_dstpos();
  inline void set_allocated_dstpos(::ProtoBuf::Vector3PB* dstpos);

  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string token = 6;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 6;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional uint32 dstMapId = 7;
  inline bool has_dstmapid() const;
  inline void clear_dstmapid();
  static const int kDstMapIdFieldNumber = 7;
  inline ::google::protobuf::uint32 dstmapid() const;
  inline void set_dstmapid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.CenterRspSceneId)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_dstsceneid();
  inline void clear_has_dstsceneid();
  inline void set_has_dstpos();
  inline void clear_has_dstpos();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_dstmapid();
  inline void clear_has_dstmapid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 retcode_;
  ::google::protobuf::uint32 dstsceneid_;
  ::ProtoBuf::Vector3PB* dstpos_;
  ::std::string* ip_;
  ::std::string* token_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 dstmapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static CenterRspSceneId* default_instance_;
};
// -------------------------------------------------------------------

class CenterDailyUpdateNotify : public ::google::protobuf::Message {
 public:
  CenterDailyUpdateNotify();
  virtual ~CenterDailyUpdateNotify();

  CenterDailyUpdateNotify(const CenterDailyUpdateNotify& from);

  inline CenterDailyUpdateNotify& operator=(const CenterDailyUpdateNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CenterDailyUpdateNotify& default_instance();

  void Swap(CenterDailyUpdateNotify* other);

  // implements Message ----------------------------------------------

  CenterDailyUpdateNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CenterDailyUpdateNotify& from);
  void MergeFrom(const CenterDailyUpdateNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 updateDailyTime = 1;
  inline bool has_updatedailytime() const;
  inline void clear_updatedailytime();
  static const int kUpdateDailyTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 updatedailytime() const;
  inline void set_updatedailytime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.CenterDailyUpdateNotify)
 private:
  inline void set_has_updatedailytime();
  inline void clear_has_updatedailytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 updatedailytime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static CenterDailyUpdateNotify* default_instance_;
};
// -------------------------------------------------------------------

class CenterWeekUpdateNotify : public ::google::protobuf::Message {
 public:
  CenterWeekUpdateNotify();
  virtual ~CenterWeekUpdateNotify();

  CenterWeekUpdateNotify(const CenterWeekUpdateNotify& from);

  inline CenterWeekUpdateNotify& operator=(const CenterWeekUpdateNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CenterWeekUpdateNotify& default_instance();

  void Swap(CenterWeekUpdateNotify* other);

  // implements Message ----------------------------------------------

  CenterWeekUpdateNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CenterWeekUpdateNotify& from);
  void MergeFrom(const CenterWeekUpdateNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 updateDailyTime = 1;
  inline bool has_updatedailytime() const;
  inline void clear_updatedailytime();
  static const int kUpdateDailyTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 updatedailytime() const;
  inline void set_updatedailytime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ProtoBuf.CenterWeekUpdateNotify)
 private:
  inline void set_has_updatedailytime();
  inline void clear_has_updatedailytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 updatedailytime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_AssignDesc_ProtoBuffer_2fServerInternalProtocol_2eproto();
  friend void protobuf_ShutdownFile_ProtoBuffer_2fServerInternalProtocol_2eproto();

  void InitAsDefaultInstance();
  static CenterWeekUpdateNotify* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginServerRegiste

// required uint32 groupId = 1;
inline bool LoginServerRegiste::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginServerRegiste::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginServerRegiste::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginServerRegiste::clear_groupid() {
  groupid_ = 0u;
  clear_has_groupid();
}
inline ::google::protobuf::uint32 LoginServerRegiste::groupid() const {
  return groupid_;
}
inline void LoginServerRegiste::set_groupid(::google::protobuf::uint32 value) {
  set_has_groupid();
  groupid_ = value;
}

// required uint32 serverId = 2;
inline bool LoginServerRegiste::has_serverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginServerRegiste::set_has_serverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginServerRegiste::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginServerRegiste::clear_serverid() {
  serverid_ = 0u;
  clear_has_serverid();
}
inline ::google::protobuf::uint32 LoginServerRegiste::serverid() const {
  return serverid_;
}
inline void LoginServerRegiste::set_serverid(::google::protobuf::uint32 value) {
  set_has_serverid();
  serverid_ = value;
}

// required uint32 outerPort = 3;
inline bool LoginServerRegiste::has_outerport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginServerRegiste::set_has_outerport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginServerRegiste::clear_has_outerport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginServerRegiste::clear_outerport() {
  outerport_ = 0u;
  clear_has_outerport();
}
inline ::google::protobuf::uint32 LoginServerRegiste::outerport() const {
  return outerport_;
}
inline void LoginServerRegiste::set_outerport(::google::protobuf::uint32 value) {
  set_has_outerport();
  outerport_ = value;
}

// required string outerIp = 4;
inline bool LoginServerRegiste::has_outerip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginServerRegiste::set_has_outerip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginServerRegiste::clear_has_outerip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginServerRegiste::clear_outerip() {
  if (outerip_ != &::google::protobuf::internal::kEmptyString) {
    outerip_->clear();
  }
  clear_has_outerip();
}
inline const ::std::string& LoginServerRegiste::outerip() const {
  return *outerip_;
}
inline void LoginServerRegiste::set_outerip(const ::std::string& value) {
  set_has_outerip();
  if (outerip_ == &::google::protobuf::internal::kEmptyString) {
    outerip_ = new ::std::string;
  }
  outerip_->assign(value);
}
inline void LoginServerRegiste::set_outerip(const char* value) {
  set_has_outerip();
  if (outerip_ == &::google::protobuf::internal::kEmptyString) {
    outerip_ = new ::std::string;
  }
  outerip_->assign(value);
}
inline void LoginServerRegiste::set_outerip(const char* value, size_t size) {
  set_has_outerip();
  if (outerip_ == &::google::protobuf::internal::kEmptyString) {
    outerip_ = new ::std::string;
  }
  outerip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginServerRegiste::mutable_outerip() {
  set_has_outerip();
  if (outerip_ == &::google::protobuf::internal::kEmptyString) {
    outerip_ = new ::std::string;
  }
  return outerip_;
}
inline ::std::string* LoginServerRegiste::release_outerip() {
  clear_has_outerip();
  if (outerip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outerip_;
    outerip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginServerRegiste::set_allocated_outerip(::std::string* outerip) {
  if (outerip_ != &::google::protobuf::internal::kEmptyString) {
    delete outerip_;
  }
  if (outerip) {
    set_has_outerip();
    outerip_ = outerip;
  } else {
    clear_has_outerip();
    outerip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogicServerRegiste

// required uint32 server_id = 1;
inline bool LogicServerRegiste::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicServerRegiste::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicServerRegiste::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicServerRegiste::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 LogicServerRegiste::server_id() const {
  return server_id_;
}
inline void LogicServerRegiste::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// required uint32 outer_port = 2;
inline bool LogicServerRegiste::has_outer_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicServerRegiste::set_has_outer_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicServerRegiste::clear_has_outer_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicServerRegiste::clear_outer_port() {
  outer_port_ = 0u;
  clear_has_outer_port();
}
inline ::google::protobuf::uint32 LogicServerRegiste::outer_port() const {
  return outer_port_;
}
inline void LogicServerRegiste::set_outer_port(::google::protobuf::uint32 value) {
  set_has_outer_port();
  outer_port_ = value;
}

// required string outer_ip = 3;
inline bool LogicServerRegiste::has_outer_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogicServerRegiste::set_has_outer_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogicServerRegiste::clear_has_outer_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogicServerRegiste::clear_outer_ip() {
  if (outer_ip_ != &::google::protobuf::internal::kEmptyString) {
    outer_ip_->clear();
  }
  clear_has_outer_ip();
}
inline const ::std::string& LogicServerRegiste::outer_ip() const {
  return *outer_ip_;
}
inline void LogicServerRegiste::set_outer_ip(const ::std::string& value) {
  set_has_outer_ip();
  if (outer_ip_ == &::google::protobuf::internal::kEmptyString) {
    outer_ip_ = new ::std::string;
  }
  outer_ip_->assign(value);
}
inline void LogicServerRegiste::set_outer_ip(const char* value) {
  set_has_outer_ip();
  if (outer_ip_ == &::google::protobuf::internal::kEmptyString) {
    outer_ip_ = new ::std::string;
  }
  outer_ip_->assign(value);
}
inline void LogicServerRegiste::set_outer_ip(const char* value, size_t size) {
  set_has_outer_ip();
  if (outer_ip_ == &::google::protobuf::internal::kEmptyString) {
    outer_ip_ = new ::std::string;
  }
  outer_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicServerRegiste::mutable_outer_ip() {
  set_has_outer_ip();
  if (outer_ip_ == &::google::protobuf::internal::kEmptyString) {
    outer_ip_ = new ::std::string;
  }
  return outer_ip_;
}
inline ::std::string* LogicServerRegiste::release_outer_ip() {
  clear_has_outer_ip();
  if (outer_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outer_ip_;
    outer_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogicServerRegiste::set_allocated_outer_ip(::std::string* outer_ip) {
  if (outer_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete outer_ip_;
  }
  if (outer_ip) {
    set_has_outer_ip();
    outer_ip_ = outer_ip;
  } else {
    clear_has_outer_ip();
    outer_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ProtoBuf.LogicServerRegiste.TYPE type = 4;
inline bool LogicServerRegiste::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogicServerRegiste::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogicServerRegiste::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogicServerRegiste::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ProtoBuf::LogicServerRegiste_TYPE LogicServerRegiste::type() const {
  return static_cast< ::ProtoBuf::LogicServerRegiste_TYPE >(type_);
}
inline void LogicServerRegiste::set_type(::ProtoBuf::LogicServerRegiste_TYPE value) {
  assert(::ProtoBuf::LogicServerRegiste_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// LoginServerState

// required uint32 state = 1;
inline bool LoginServerState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginServerState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginServerState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginServerState::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 LoginServerState::state() const {
  return state_;
}
inline void LoginServerState::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// LogicServerState

// required uint32 state = 1;
inline bool LogicServerState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicServerState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicServerState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicServerState::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 LogicServerState::state() const {
  return state_;
}
inline void LogicServerState::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// required uint32 characterCount = 2;
inline bool LogicServerState::has_charactercount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicServerState::set_has_charactercount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicServerState::clear_has_charactercount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicServerState::clear_charactercount() {
  charactercount_ = 0u;
  clear_has_charactercount();
}
inline ::google::protobuf::uint32 LogicServerState::charactercount() const {
  return charactercount_;
}
inline void LogicServerState::set_charactercount(::google::protobuf::uint32 value) {
  set_has_charactercount();
  charactercount_ = value;
}

// required uint32 playerCount = 3;
inline bool LogicServerState::has_playercount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogicServerState::set_has_playercount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogicServerState::clear_has_playercount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogicServerState::clear_playercount() {
  playercount_ = 0u;
  clear_has_playercount();
}
inline ::google::protobuf::uint32 LogicServerState::playercount() const {
  return playercount_;
}
inline void LogicServerState::set_playercount(::google::protobuf::uint32 value) {
  set_has_playercount();
  playercount_ = value;
}

// required uint32 enterAccountCount = 4;
inline bool LogicServerState::has_enteraccountcount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogicServerState::set_has_enteraccountcount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogicServerState::clear_has_enteraccountcount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogicServerState::clear_enteraccountcount() {
  enteraccountcount_ = 0u;
  clear_has_enteraccountcount();
}
inline ::google::protobuf::uint32 LogicServerState::enteraccountcount() const {
  return enteraccountcount_;
}
inline void LogicServerState::set_enteraccountcount(::google::protobuf::uint32 value) {
  set_has_enteraccountcount();
  enteraccountcount_ = value;
}

// -------------------------------------------------------------------

// AccountLoginCheckReq

// required string channel_user_id = 1;
inline bool AccountLoginCheckReq::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLoginCheckReq::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLoginCheckReq::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLoginCheckReq::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& AccountLoginCheckReq::channel_user_id() const {
  return *channel_user_id_;
}
inline void AccountLoginCheckReq::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void AccountLoginCheckReq::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void AccountLoginCheckReq::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLoginCheckReq::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* AccountLoginCheckReq::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLoginCheckReq::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 session_id = 2;
inline bool AccountLoginCheckReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLoginCheckReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLoginCheckReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLoginCheckReq::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 AccountLoginCheckReq::session_id() const {
  return session_id_;
}
inline void AccountLoginCheckReq::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// -------------------------------------------------------------------

// AccountLoginCheckRsp

// required string channel_user_id = 1;
inline bool AccountLoginCheckRsp::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLoginCheckRsp::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLoginCheckRsp::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLoginCheckRsp::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& AccountLoginCheckRsp::channel_user_id() const {
  return *channel_user_id_;
}
inline void AccountLoginCheckRsp::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void AccountLoginCheckRsp::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void AccountLoginCheckRsp::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLoginCheckRsp::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* AccountLoginCheckRsp::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLoginCheckRsp::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 group_id = 2;
inline bool AccountLoginCheckRsp::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLoginCheckRsp::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLoginCheckRsp::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLoginCheckRsp::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 AccountLoginCheckRsp::group_id() const {
  return group_id_;
}
inline void AccountLoginCheckRsp::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required string logic_ip = 3;
inline bool AccountLoginCheckRsp::has_logic_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountLoginCheckRsp::set_has_logic_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountLoginCheckRsp::clear_has_logic_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountLoginCheckRsp::clear_logic_ip() {
  if (logic_ip_ != &::google::protobuf::internal::kEmptyString) {
    logic_ip_->clear();
  }
  clear_has_logic_ip();
}
inline const ::std::string& AccountLoginCheckRsp::logic_ip() const {
  return *logic_ip_;
}
inline void AccountLoginCheckRsp::set_logic_ip(const ::std::string& value) {
  set_has_logic_ip();
  if (logic_ip_ == &::google::protobuf::internal::kEmptyString) {
    logic_ip_ = new ::std::string;
  }
  logic_ip_->assign(value);
}
inline void AccountLoginCheckRsp::set_logic_ip(const char* value) {
  set_has_logic_ip();
  if (logic_ip_ == &::google::protobuf::internal::kEmptyString) {
    logic_ip_ = new ::std::string;
  }
  logic_ip_->assign(value);
}
inline void AccountLoginCheckRsp::set_logic_ip(const char* value, size_t size) {
  set_has_logic_ip();
  if (logic_ip_ == &::google::protobuf::internal::kEmptyString) {
    logic_ip_ = new ::std::string;
  }
  logic_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLoginCheckRsp::mutable_logic_ip() {
  set_has_logic_ip();
  if (logic_ip_ == &::google::protobuf::internal::kEmptyString) {
    logic_ip_ = new ::std::string;
  }
  return logic_ip_;
}
inline ::std::string* AccountLoginCheckRsp::release_logic_ip() {
  clear_has_logic_ip();
  if (logic_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logic_ip_;
    logic_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLoginCheckRsp::set_allocated_logic_ip(::std::string* logic_ip) {
  if (logic_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete logic_ip_;
  }
  if (logic_ip) {
    set_has_logic_ip();
    logic_ip_ = logic_ip;
  } else {
    clear_has_logic_ip();
    logic_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 logic_port = 4;
inline bool AccountLoginCheckRsp::has_logic_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountLoginCheckRsp::set_has_logic_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountLoginCheckRsp::clear_has_logic_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountLoginCheckRsp::clear_logic_port() {
  logic_port_ = 0u;
  clear_has_logic_port();
}
inline ::google::protobuf::uint32 AccountLoginCheckRsp::logic_port() const {
  return logic_port_;
}
inline void AccountLoginCheckRsp::set_logic_port(::google::protobuf::uint32 value) {
  set_has_logic_port();
  logic_port_ = value;
}

// required uint64 logic_token = 5;
inline bool AccountLoginCheckRsp::has_logic_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountLoginCheckRsp::set_has_logic_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountLoginCheckRsp::clear_has_logic_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountLoginCheckRsp::clear_logic_token() {
  logic_token_ = GOOGLE_ULONGLONG(0);
  clear_has_logic_token();
}
inline ::google::protobuf::uint64 AccountLoginCheckRsp::logic_token() const {
  return logic_token_;
}
inline void AccountLoginCheckRsp::set_logic_token(::google::protobuf::uint64 value) {
  set_has_logic_token();
  logic_token_ = value;
}

// required uint32 session_id = 6;
inline bool AccountLoginCheckRsp::has_session_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountLoginCheckRsp::set_has_session_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountLoginCheckRsp::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountLoginCheckRsp::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 AccountLoginCheckRsp::session_id() const {
  return session_id_;
}
inline void AccountLoginCheckRsp::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// -------------------------------------------------------------------

// AccountLogoutNotify

// required string channel_user_id = 1;
inline bool AccountLogoutNotify::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLogoutNotify::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLogoutNotify::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLogoutNotify::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& AccountLogoutNotify::channel_user_id() const {
  return *channel_user_id_;
}
inline void AccountLogoutNotify::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void AccountLogoutNotify::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void AccountLogoutNotify::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLogoutNotify::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* AccountLogoutNotify::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLogoutNotify::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogicCheckTokenReq

// required string channel_user_id = 1;
inline bool LogicCheckTokenReq::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicCheckTokenReq::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicCheckTokenReq::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicCheckTokenReq::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& LogicCheckTokenReq::channel_user_id() const {
  return *channel_user_id_;
}
inline void LogicCheckTokenReq::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LogicCheckTokenReq::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LogicCheckTokenReq::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicCheckTokenReq::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* LogicCheckTokenReq::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogicCheckTokenReq::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 logic_token = 2;
inline bool LogicCheckTokenReq::has_logic_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicCheckTokenReq::set_has_logic_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicCheckTokenReq::clear_has_logic_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicCheckTokenReq::clear_logic_token() {
  logic_token_ = GOOGLE_ULONGLONG(0);
  clear_has_logic_token();
}
inline ::google::protobuf::uint64 LogicCheckTokenReq::logic_token() const {
  return logic_token_;
}
inline void LogicCheckTokenReq::set_logic_token(::google::protobuf::uint64 value) {
  set_has_logic_token();
  logic_token_ = value;
}

// -------------------------------------------------------------------

// LogicCheckTokenRsp

// required int32 retcode = 1;
inline bool LogicCheckTokenRsp::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicCheckTokenRsp::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicCheckTokenRsp::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicCheckTokenRsp::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 LogicCheckTokenRsp::retcode() const {
  return retcode_;
}
inline void LogicCheckTokenRsp::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// required string channel_user_id = 2;
inline bool LogicCheckTokenRsp::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicCheckTokenRsp::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicCheckTokenRsp::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicCheckTokenRsp::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& LogicCheckTokenRsp::channel_user_id() const {
  return *channel_user_id_;
}
inline void LogicCheckTokenRsp::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LogicCheckTokenRsp::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LogicCheckTokenRsp::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicCheckTokenRsp::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* LogicCheckTokenRsp::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogicCheckTokenRsp::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// KickChannelUserNotify

// required string channel_user_id = 1;
inline bool KickChannelUserNotify::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickChannelUserNotify::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickChannelUserNotify::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickChannelUserNotify::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& KickChannelUserNotify::channel_user_id() const {
  return *channel_user_id_;
}
inline void KickChannelUserNotify::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void KickChannelUserNotify::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void KickChannelUserNotify::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KickChannelUserNotify::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* KickChannelUserNotify::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KickChannelUserNotify::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 charID = 2;
inline bool KickChannelUserNotify::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickChannelUserNotify::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickChannelUserNotify::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickChannelUserNotify::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 KickChannelUserNotify::charid() const {
  return charid_;
}
inline void KickChannelUserNotify::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// CenterAccountLogoutNotify

// required .ProtoBuf.CenterAccountLogoutNotify.TYPE type = 1;
inline bool CenterAccountLogoutNotify::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterAccountLogoutNotify::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterAccountLogoutNotify::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterAccountLogoutNotify::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ProtoBuf::CenterAccountLogoutNotify_TYPE CenterAccountLogoutNotify::type() const {
  return static_cast< ::ProtoBuf::CenterAccountLogoutNotify_TYPE >(type_);
}
inline void CenterAccountLogoutNotify::set_type(::ProtoBuf::CenterAccountLogoutNotify_TYPE value) {
  assert(::ProtoBuf::CenterAccountLogoutNotify_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string channel_user_id = 2;
inline bool CenterAccountLogoutNotify::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CenterAccountLogoutNotify::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CenterAccountLogoutNotify::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CenterAccountLogoutNotify::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& CenterAccountLogoutNotify::channel_user_id() const {
  return *channel_user_id_;
}
inline void CenterAccountLogoutNotify::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void CenterAccountLogoutNotify::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void CenterAccountLogoutNotify::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CenterAccountLogoutNotify::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* CenterAccountLogoutNotify::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CenterAccountLogoutNotify::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReconnectCheckRequest

// required uint32 charId = 1;
inline bool ReconnectCheckRequest::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReconnectCheckRequest::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReconnectCheckRequest::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReconnectCheckRequest::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 ReconnectCheckRequest::charid() const {
  return charid_;
}
inline void ReconnectCheckRequest::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// required string channel_user_id = 2;
inline bool ReconnectCheckRequest::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReconnectCheckRequest::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReconnectCheckRequest::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReconnectCheckRequest::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& ReconnectCheckRequest::channel_user_id() const {
  return *channel_user_id_;
}
inline void ReconnectCheckRequest::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void ReconnectCheckRequest::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void ReconnectCheckRequest::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconnectCheckRequest::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* ReconnectCheckRequest::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconnectCheckRequest::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 accountIndex = 3;
inline bool ReconnectCheckRequest::has_accountindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReconnectCheckRequest::set_has_accountindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReconnectCheckRequest::clear_has_accountindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReconnectCheckRequest::clear_accountindex() {
  accountindex_ = 0u;
  clear_has_accountindex();
}
inline ::google::protobuf::uint32 ReconnectCheckRequest::accountindex() const {
  return accountindex_;
}
inline void ReconnectCheckRequest::set_accountindex(::google::protobuf::uint32 value) {
  set_has_accountindex();
  accountindex_ = value;
}

// required uint64 token = 4;
inline bool ReconnectCheckRequest::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReconnectCheckRequest::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReconnectCheckRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReconnectCheckRequest::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 ReconnectCheckRequest::token() const {
  return token_;
}
inline void ReconnectCheckRequest::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
}

// required string channelId = 5;
inline bool ReconnectCheckRequest::has_channelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReconnectCheckRequest::set_has_channelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReconnectCheckRequest::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReconnectCheckRequest::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& ReconnectCheckRequest::channelid() const {
  return *channelid_;
}
inline void ReconnectCheckRequest::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void ReconnectCheckRequest::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void ReconnectCheckRequest::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconnectCheckRequest::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* ReconnectCheckRequest::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconnectCheckRequest::set_allocated_channelid(::std::string* channelid) {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    delete channelid_;
  }
  if (channelid) {
    set_has_channelid();
    channelid_ = channelid;
  } else {
    clear_has_channelid();
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userId = 6;
inline bool ReconnectCheckRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReconnectCheckRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReconnectCheckRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReconnectCheckRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& ReconnectCheckRequest::userid() const {
  return *userid_;
}
inline void ReconnectCheckRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ReconnectCheckRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ReconnectCheckRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconnectCheckRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* ReconnectCheckRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconnectCheckRequest::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReconnectCheckResponse

// required uint32 retCode = 1;
inline bool ReconnectCheckResponse::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReconnectCheckResponse::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReconnectCheckResponse::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReconnectCheckResponse::clear_retcode() {
  retcode_ = 0u;
  clear_has_retcode();
}
inline ::google::protobuf::uint32 ReconnectCheckResponse::retcode() const {
  return retcode_;
}
inline void ReconnectCheckResponse::set_retcode(::google::protobuf::uint32 value) {
  set_has_retcode();
  retcode_ = value;
}

// required uint32 charId = 2;
inline bool ReconnectCheckResponse::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReconnectCheckResponse::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReconnectCheckResponse::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReconnectCheckResponse::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 ReconnectCheckResponse::charid() const {
  return charid_;
}
inline void ReconnectCheckResponse::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// required string channel_user_id = 3;
inline bool ReconnectCheckResponse::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReconnectCheckResponse::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReconnectCheckResponse::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReconnectCheckResponse::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& ReconnectCheckResponse::channel_user_id() const {
  return *channel_user_id_;
}
inline void ReconnectCheckResponse::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void ReconnectCheckResponse::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void ReconnectCheckResponse::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconnectCheckResponse::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* ReconnectCheckResponse::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconnectCheckResponse::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 accountIndex = 4;
inline bool ReconnectCheckResponse::has_accountindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReconnectCheckResponse::set_has_accountindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReconnectCheckResponse::clear_has_accountindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReconnectCheckResponse::clear_accountindex() {
  accountindex_ = 0u;
  clear_has_accountindex();
}
inline ::google::protobuf::uint32 ReconnectCheckResponse::accountindex() const {
  return accountindex_;
}
inline void ReconnectCheckResponse::set_accountindex(::google::protobuf::uint32 value) {
  set_has_accountindex();
  accountindex_ = value;
}

// required uint64 token = 5;
inline bool ReconnectCheckResponse::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReconnectCheckResponse::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReconnectCheckResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReconnectCheckResponse::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 ReconnectCheckResponse::token() const {
  return token_;
}
inline void ReconnectCheckResponse::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
}

// required string channelId = 6;
inline bool ReconnectCheckResponse::has_channelid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReconnectCheckResponse::set_has_channelid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReconnectCheckResponse::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReconnectCheckResponse::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& ReconnectCheckResponse::channelid() const {
  return *channelid_;
}
inline void ReconnectCheckResponse::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void ReconnectCheckResponse::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void ReconnectCheckResponse::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconnectCheckResponse::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* ReconnectCheckResponse::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconnectCheckResponse::set_allocated_channelid(::std::string* channelid) {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    delete channelid_;
  }
  if (channelid) {
    set_has_channelid();
    channelid_ = channelid;
  } else {
    clear_has_channelid();
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userId = 7;
inline bool ReconnectCheckResponse::has_userid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReconnectCheckResponse::set_has_userid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReconnectCheckResponse::clear_has_userid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReconnectCheckResponse::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& ReconnectCheckResponse::userid() const {
  return *userid_;
}
inline void ReconnectCheckResponse::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ReconnectCheckResponse::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ReconnectCheckResponse::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconnectCheckResponse::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* ReconnectCheckResponse::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconnectCheckResponse::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogicServerAddressReq

// required string app_guid = 1;
inline bool LogicServerAddressReq::has_app_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicServerAddressReq::set_has_app_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicServerAddressReq::clear_has_app_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicServerAddressReq::clear_app_guid() {
  if (app_guid_ != &::google::protobuf::internal::kEmptyString) {
    app_guid_->clear();
  }
  clear_has_app_guid();
}
inline const ::std::string& LogicServerAddressReq::app_guid() const {
  return *app_guid_;
}
inline void LogicServerAddressReq::set_app_guid(const ::std::string& value) {
  set_has_app_guid();
  if (app_guid_ == &::google::protobuf::internal::kEmptyString) {
    app_guid_ = new ::std::string;
  }
  app_guid_->assign(value);
}
inline void LogicServerAddressReq::set_app_guid(const char* value) {
  set_has_app_guid();
  if (app_guid_ == &::google::protobuf::internal::kEmptyString) {
    app_guid_ = new ::std::string;
  }
  app_guid_->assign(value);
}
inline void LogicServerAddressReq::set_app_guid(const char* value, size_t size) {
  set_has_app_guid();
  if (app_guid_ == &::google::protobuf::internal::kEmptyString) {
    app_guid_ = new ::std::string;
  }
  app_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicServerAddressReq::mutable_app_guid() {
  set_has_app_guid();
  if (app_guid_ == &::google::protobuf::internal::kEmptyString) {
    app_guid_ = new ::std::string;
  }
  return app_guid_;
}
inline ::std::string* LogicServerAddressReq::release_app_guid() {
  clear_has_app_guid();
  if (app_guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_guid_;
    app_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogicServerAddressReq::set_allocated_app_guid(::std::string* app_guid) {
  if (app_guid_ != &::google::protobuf::internal::kEmptyString) {
    delete app_guid_;
  }
  if (app_guid) {
    set_has_app_guid();
    app_guid_ = app_guid;
  } else {
    clear_has_app_guid();
    app_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string channel_id = 2;
inline bool LogicServerAddressReq::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicServerAddressReq::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicServerAddressReq::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicServerAddressReq::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& LogicServerAddressReq::channel_id() const {
  return *channel_id_;
}
inline void LogicServerAddressReq::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void LogicServerAddressReq::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void LogicServerAddressReq::set_channel_id(const char* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicServerAddressReq::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* LogicServerAddressReq::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogicServerAddressReq::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user_id = 3;
inline bool LogicServerAddressReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogicServerAddressReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogicServerAddressReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogicServerAddressReq::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& LogicServerAddressReq::user_id() const {
  return *user_id_;
}
inline void LogicServerAddressReq::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void LogicServerAddressReq::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void LogicServerAddressReq::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicServerAddressReq::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* LogicServerAddressReq::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogicServerAddressReq::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginLogicRequest

// required uint32 connect_index = 1;
inline bool LoginLogicRequest::has_connect_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginLogicRequest::set_has_connect_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginLogicRequest::clear_has_connect_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginLogicRequest::clear_connect_index() {
  connect_index_ = 0u;
  clear_has_connect_index();
}
inline ::google::protobuf::uint32 LoginLogicRequest::connect_index() const {
  return connect_index_;
}
inline void LoginLogicRequest::set_connect_index(::google::protobuf::uint32 value) {
  set_has_connect_index();
  connect_index_ = value;
}

// required string channel_user_id = 2;
inline bool LoginLogicRequest::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginLogicRequest::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginLogicRequest::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginLogicRequest::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& LoginLogicRequest::channel_user_id() const {
  return *channel_user_id_;
}
inline void LoginLogicRequest::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LoginLogicRequest::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LoginLogicRequest::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginLogicRequest::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* LoginLogicRequest::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginLogicRequest::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 token = 3;
inline bool LoginLogicRequest::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginLogicRequest::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginLogicRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginLogicRequest::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 LoginLogicRequest::token() const {
  return token_;
}
inline void LoginLogicRequest::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
}

// required uint32 group_id = 4;
inline bool LoginLogicRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginLogicRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginLogicRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginLogicRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 LoginLogicRequest::group_id() const {
  return group_id_;
}
inline void LoginLogicRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// LoginLogicResponse_SwitchServerParam

// required uint32 character_id = 1;
inline bool LoginLogicResponse_SwitchServerParam::has_character_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginLogicResponse_SwitchServerParam::set_has_character_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 LoginLogicResponse_SwitchServerParam::character_id() const {
  return character_id_;
}
inline void LoginLogicResponse_SwitchServerParam::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
}

// required uint32 source_scene_template_id = 2;
inline bool LoginLogicResponse_SwitchServerParam::has_source_scene_template_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginLogicResponse_SwitchServerParam::set_has_source_scene_template_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_has_source_scene_template_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_source_scene_template_id() {
  source_scene_template_id_ = 0u;
  clear_has_source_scene_template_id();
}
inline ::google::protobuf::uint32 LoginLogicResponse_SwitchServerParam::source_scene_template_id() const {
  return source_scene_template_id_;
}
inline void LoginLogicResponse_SwitchServerParam::set_source_scene_template_id(::google::protobuf::uint32 value) {
  set_has_source_scene_template_id();
  source_scene_template_id_ = value;
}

// required float source_pose_x = 3;
inline bool LoginLogicResponse_SwitchServerParam::has_source_pose_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginLogicResponse_SwitchServerParam::set_has_source_pose_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_has_source_pose_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_source_pose_x() {
  source_pose_x_ = 0;
  clear_has_source_pose_x();
}
inline float LoginLogicResponse_SwitchServerParam::source_pose_x() const {
  return source_pose_x_;
}
inline void LoginLogicResponse_SwitchServerParam::set_source_pose_x(float value) {
  set_has_source_pose_x();
  source_pose_x_ = value;
}

// required float source_pose_y = 4;
inline bool LoginLogicResponse_SwitchServerParam::has_source_pose_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginLogicResponse_SwitchServerParam::set_has_source_pose_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_has_source_pose_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_source_pose_y() {
  source_pose_y_ = 0;
  clear_has_source_pose_y();
}
inline float LoginLogicResponse_SwitchServerParam::source_pose_y() const {
  return source_pose_y_;
}
inline void LoginLogicResponse_SwitchServerParam::set_source_pose_y(float value) {
  set_has_source_pose_y();
  source_pose_y_ = value;
}

// required uint32 dest_scene_template_id = 5;
inline bool LoginLogicResponse_SwitchServerParam::has_dest_scene_template_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginLogicResponse_SwitchServerParam::set_has_dest_scene_template_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_has_dest_scene_template_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_dest_scene_template_id() {
  dest_scene_template_id_ = 0u;
  clear_has_dest_scene_template_id();
}
inline ::google::protobuf::uint32 LoginLogicResponse_SwitchServerParam::dest_scene_template_id() const {
  return dest_scene_template_id_;
}
inline void LoginLogicResponse_SwitchServerParam::set_dest_scene_template_id(::google::protobuf::uint32 value) {
  set_has_dest_scene_template_id();
  dest_scene_template_id_ = value;
}

// required uint32 dest_scene_instance_id = 6;
inline bool LoginLogicResponse_SwitchServerParam::has_dest_scene_instance_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginLogicResponse_SwitchServerParam::set_has_dest_scene_instance_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_has_dest_scene_instance_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_dest_scene_instance_id() {
  dest_scene_instance_id_ = 0u;
  clear_has_dest_scene_instance_id();
}
inline ::google::protobuf::uint32 LoginLogicResponse_SwitchServerParam::dest_scene_instance_id() const {
  return dest_scene_instance_id_;
}
inline void LoginLogicResponse_SwitchServerParam::set_dest_scene_instance_id(::google::protobuf::uint32 value) {
  set_has_dest_scene_instance_id();
  dest_scene_instance_id_ = value;
}

// required uint64 dest_scene_enter_key = 7;
inline bool LoginLogicResponse_SwitchServerParam::has_dest_scene_enter_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginLogicResponse_SwitchServerParam::set_has_dest_scene_enter_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_has_dest_scene_enter_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_dest_scene_enter_key() {
  dest_scene_enter_key_ = GOOGLE_ULONGLONG(0);
  clear_has_dest_scene_enter_key();
}
inline ::google::protobuf::uint64 LoginLogicResponse_SwitchServerParam::dest_scene_enter_key() const {
  return dest_scene_enter_key_;
}
inline void LoginLogicResponse_SwitchServerParam::set_dest_scene_enter_key(::google::protobuf::uint64 value) {
  set_has_dest_scene_enter_key();
  dest_scene_enter_key_ = value;
}

// required float dest_scene_pos_x = 8;
inline bool LoginLogicResponse_SwitchServerParam::has_dest_scene_pos_x() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginLogicResponse_SwitchServerParam::set_has_dest_scene_pos_x() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_has_dest_scene_pos_x() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_dest_scene_pos_x() {
  dest_scene_pos_x_ = 0;
  clear_has_dest_scene_pos_x();
}
inline float LoginLogicResponse_SwitchServerParam::dest_scene_pos_x() const {
  return dest_scene_pos_x_;
}
inline void LoginLogicResponse_SwitchServerParam::set_dest_scene_pos_x(float value) {
  set_has_dest_scene_pos_x();
  dest_scene_pos_x_ = value;
}

// required float dest_scene_pos_y = 9;
inline bool LoginLogicResponse_SwitchServerParam::has_dest_scene_pos_y() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginLogicResponse_SwitchServerParam::set_has_dest_scene_pos_y() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_has_dest_scene_pos_y() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginLogicResponse_SwitchServerParam::clear_dest_scene_pos_y() {
  dest_scene_pos_y_ = 0;
  clear_has_dest_scene_pos_y();
}
inline float LoginLogicResponse_SwitchServerParam::dest_scene_pos_y() const {
  return dest_scene_pos_y_;
}
inline void LoginLogicResponse_SwitchServerParam::set_dest_scene_pos_y(float value) {
  set_has_dest_scene_pos_y();
  dest_scene_pos_y_ = value;
}

// -------------------------------------------------------------------

// LoginLogicResponse

// required uint32 connect_index = 1;
inline bool LoginLogicResponse::has_connect_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginLogicResponse::set_has_connect_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginLogicResponse::clear_has_connect_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginLogicResponse::clear_connect_index() {
  connect_index_ = 0u;
  clear_has_connect_index();
}
inline ::google::protobuf::uint32 LoginLogicResponse::connect_index() const {
  return connect_index_;
}
inline void LoginLogicResponse::set_connect_index(::google::protobuf::uint32 value) {
  set_has_connect_index();
  connect_index_ = value;
}

// required .ProtoBuf.LoginLogicResponse.RESULT result = 2;
inline bool LoginLogicResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginLogicResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginLogicResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginLogicResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::ProtoBuf::LoginLogicResponse_RESULT LoginLogicResponse::result() const {
  return static_cast< ::ProtoBuf::LoginLogicResponse_RESULT >(result_);
}
inline void LoginLogicResponse::set_result(::ProtoBuf::LoginLogicResponse_RESULT value) {
  assert(::ProtoBuf::LoginLogicResponse_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional string channel_user_id = 3;
inline bool LoginLogicResponse::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginLogicResponse::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginLogicResponse::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginLogicResponse::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& LoginLogicResponse::channel_user_id() const {
  return *channel_user_id_;
}
inline void LoginLogicResponse::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LoginLogicResponse::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LoginLogicResponse::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginLogicResponse::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* LoginLogicResponse::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginLogicResponse::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 group_id = 4;
inline bool LoginLogicResponse::has_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginLogicResponse::set_has_group_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginLogicResponse::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginLogicResponse::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 LoginLogicResponse::group_id() const {
  return group_id_;
}
inline void LoginLogicResponse::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional uint32 switch_server_flag = 6;
inline bool LoginLogicResponse::has_switch_server_flag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginLogicResponse::set_has_switch_server_flag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginLogicResponse::clear_has_switch_server_flag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginLogicResponse::clear_switch_server_flag() {
  switch_server_flag_ = 0u;
  clear_has_switch_server_flag();
}
inline ::google::protobuf::uint32 LoginLogicResponse::switch_server_flag() const {
  return switch_server_flag_;
}
inline void LoginLogicResponse::set_switch_server_flag(::google::protobuf::uint32 value) {
  set_has_switch_server_flag();
  switch_server_flag_ = value;
}

// optional .ProtoBuf.LoginLogicResponse.SwitchServerParam switch_server_param = 7;
inline bool LoginLogicResponse::has_switch_server_param() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginLogicResponse::set_has_switch_server_param() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginLogicResponse::clear_has_switch_server_param() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginLogicResponse::clear_switch_server_param() {
  if (switch_server_param_ != NULL) switch_server_param_->::ProtoBuf::LoginLogicResponse_SwitchServerParam::Clear();
  clear_has_switch_server_param();
}
inline const ::ProtoBuf::LoginLogicResponse_SwitchServerParam& LoginLogicResponse::switch_server_param() const {
  return switch_server_param_ != NULL ? *switch_server_param_ : *default_instance_->switch_server_param_;
}
inline ::ProtoBuf::LoginLogicResponse_SwitchServerParam* LoginLogicResponse::mutable_switch_server_param() {
  set_has_switch_server_param();
  if (switch_server_param_ == NULL) switch_server_param_ = new ::ProtoBuf::LoginLogicResponse_SwitchServerParam;
  return switch_server_param_;
}
inline ::ProtoBuf::LoginLogicResponse_SwitchServerParam* LoginLogicResponse::release_switch_server_param() {
  clear_has_switch_server_param();
  ::ProtoBuf::LoginLogicResponse_SwitchServerParam* temp = switch_server_param_;
  switch_server_param_ = NULL;
  return temp;
}
inline void LoginLogicResponse::set_allocated_switch_server_param(::ProtoBuf::LoginLogicResponse_SwitchServerParam* switch_server_param) {
  delete switch_server_param_;
  switch_server_param_ = switch_server_param;
  if (switch_server_param) {
    set_has_switch_server_param();
  } else {
    clear_has_switch_server_param();
  }
}

// -------------------------------------------------------------------

// SwitchServerBeginNotify

// required string channel_id = 1;
inline bool SwitchServerBeginNotify::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchServerBeginNotify::set_has_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwitchServerBeginNotify::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwitchServerBeginNotify::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& SwitchServerBeginNotify::channel_id() const {
  return *channel_id_;
}
inline void SwitchServerBeginNotify::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void SwitchServerBeginNotify::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void SwitchServerBeginNotify::set_channel_id(const char* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchServerBeginNotify::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* SwitchServerBeginNotify::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwitchServerBeginNotify::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user_id = 2;
inline bool SwitchServerBeginNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwitchServerBeginNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwitchServerBeginNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwitchServerBeginNotify::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& SwitchServerBeginNotify::user_id() const {
  return *user_id_;
}
inline void SwitchServerBeginNotify::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void SwitchServerBeginNotify::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void SwitchServerBeginNotify::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchServerBeginNotify::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* SwitchServerBeginNotify::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwitchServerBeginNotify::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 character_id = 3;
inline bool SwitchServerBeginNotify::has_character_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwitchServerBeginNotify::set_has_character_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwitchServerBeginNotify::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwitchServerBeginNotify::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 SwitchServerBeginNotify::character_id() const {
  return character_id_;
}
inline void SwitchServerBeginNotify::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
}

// required uint32 source_scene_template_id = 4;
inline bool SwitchServerBeginNotify::has_source_scene_template_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SwitchServerBeginNotify::set_has_source_scene_template_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SwitchServerBeginNotify::clear_has_source_scene_template_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SwitchServerBeginNotify::clear_source_scene_template_id() {
  source_scene_template_id_ = 0u;
  clear_has_source_scene_template_id();
}
inline ::google::protobuf::uint32 SwitchServerBeginNotify::source_scene_template_id() const {
  return source_scene_template_id_;
}
inline void SwitchServerBeginNotify::set_source_scene_template_id(::google::protobuf::uint32 value) {
  set_has_source_scene_template_id();
  source_scene_template_id_ = value;
}

// required float source_pose_x = 5;
inline bool SwitchServerBeginNotify::has_source_pose_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SwitchServerBeginNotify::set_has_source_pose_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SwitchServerBeginNotify::clear_has_source_pose_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SwitchServerBeginNotify::clear_source_pose_x() {
  source_pose_x_ = 0;
  clear_has_source_pose_x();
}
inline float SwitchServerBeginNotify::source_pose_x() const {
  return source_pose_x_;
}
inline void SwitchServerBeginNotify::set_source_pose_x(float value) {
  set_has_source_pose_x();
  source_pose_x_ = value;
}

// required float source_pose_y = 6;
inline bool SwitchServerBeginNotify::has_source_pose_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SwitchServerBeginNotify::set_has_source_pose_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SwitchServerBeginNotify::clear_has_source_pose_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SwitchServerBeginNotify::clear_source_pose_y() {
  source_pose_y_ = 0;
  clear_has_source_pose_y();
}
inline float SwitchServerBeginNotify::source_pose_y() const {
  return source_pose_y_;
}
inline void SwitchServerBeginNotify::set_source_pose_y(float value) {
  set_has_source_pose_y();
  source_pose_y_ = value;
}

// required uint32 dest_logic_service_id = 7;
inline bool SwitchServerBeginNotify::has_dest_logic_service_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SwitchServerBeginNotify::set_has_dest_logic_service_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SwitchServerBeginNotify::clear_has_dest_logic_service_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SwitchServerBeginNotify::clear_dest_logic_service_id() {
  dest_logic_service_id_ = 0u;
  clear_has_dest_logic_service_id();
}
inline ::google::protobuf::uint32 SwitchServerBeginNotify::dest_logic_service_id() const {
  return dest_logic_service_id_;
}
inline void SwitchServerBeginNotify::set_dest_logic_service_id(::google::protobuf::uint32 value) {
  set_has_dest_logic_service_id();
  dest_logic_service_id_ = value;
}

// required uint32 dest_scene_template_id = 8;
inline bool SwitchServerBeginNotify::has_dest_scene_template_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SwitchServerBeginNotify::set_has_dest_scene_template_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SwitchServerBeginNotify::clear_has_dest_scene_template_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SwitchServerBeginNotify::clear_dest_scene_template_id() {
  dest_scene_template_id_ = 0u;
  clear_has_dest_scene_template_id();
}
inline ::google::protobuf::uint32 SwitchServerBeginNotify::dest_scene_template_id() const {
  return dest_scene_template_id_;
}
inline void SwitchServerBeginNotify::set_dest_scene_template_id(::google::protobuf::uint32 value) {
  set_has_dest_scene_template_id();
  dest_scene_template_id_ = value;
}

// required uint32 dest_scene_instance_id = 9;
inline bool SwitchServerBeginNotify::has_dest_scene_instance_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SwitchServerBeginNotify::set_has_dest_scene_instance_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SwitchServerBeginNotify::clear_has_dest_scene_instance_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SwitchServerBeginNotify::clear_dest_scene_instance_id() {
  dest_scene_instance_id_ = 0u;
  clear_has_dest_scene_instance_id();
}
inline ::google::protobuf::uint32 SwitchServerBeginNotify::dest_scene_instance_id() const {
  return dest_scene_instance_id_;
}
inline void SwitchServerBeginNotify::set_dest_scene_instance_id(::google::protobuf::uint32 value) {
  set_has_dest_scene_instance_id();
  dest_scene_instance_id_ = value;
}

// required uint64 dest_scene_enter_key = 10;
inline bool SwitchServerBeginNotify::has_dest_scene_enter_key() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SwitchServerBeginNotify::set_has_dest_scene_enter_key() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SwitchServerBeginNotify::clear_has_dest_scene_enter_key() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SwitchServerBeginNotify::clear_dest_scene_enter_key() {
  dest_scene_enter_key_ = GOOGLE_ULONGLONG(0);
  clear_has_dest_scene_enter_key();
}
inline ::google::protobuf::uint64 SwitchServerBeginNotify::dest_scene_enter_key() const {
  return dest_scene_enter_key_;
}
inline void SwitchServerBeginNotify::set_dest_scene_enter_key(::google::protobuf::uint64 value) {
  set_has_dest_scene_enter_key();
  dest_scene_enter_key_ = value;
}

// required float dest_scene_pos_x = 11;
inline bool SwitchServerBeginNotify::has_dest_scene_pos_x() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SwitchServerBeginNotify::set_has_dest_scene_pos_x() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SwitchServerBeginNotify::clear_has_dest_scene_pos_x() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SwitchServerBeginNotify::clear_dest_scene_pos_x() {
  dest_scene_pos_x_ = 0;
  clear_has_dest_scene_pos_x();
}
inline float SwitchServerBeginNotify::dest_scene_pos_x() const {
  return dest_scene_pos_x_;
}
inline void SwitchServerBeginNotify::set_dest_scene_pos_x(float value) {
  set_has_dest_scene_pos_x();
  dest_scene_pos_x_ = value;
}

// required float dest_scene_pos_y = 12;
inline bool SwitchServerBeginNotify::has_dest_scene_pos_y() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SwitchServerBeginNotify::set_has_dest_scene_pos_y() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SwitchServerBeginNotify::clear_has_dest_scene_pos_y() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SwitchServerBeginNotify::clear_dest_scene_pos_y() {
  dest_scene_pos_y_ = 0;
  clear_has_dest_scene_pos_y();
}
inline float SwitchServerBeginNotify::dest_scene_pos_y() const {
  return dest_scene_pos_y_;
}
inline void SwitchServerBeginNotify::set_dest_scene_pos_y(float value) {
  set_has_dest_scene_pos_y();
  dest_scene_pos_y_ = value;
}

// -------------------------------------------------------------------

// BroadcastToLogicServer

// required uint32 groupId = 1;
inline bool BroadcastToLogicServer::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastToLogicServer::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastToLogicServer::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastToLogicServer::clear_groupid() {
  groupid_ = 0u;
  clear_has_groupid();
}
inline ::google::protobuf::uint32 BroadcastToLogicServer::groupid() const {
  return groupid_;
}
inline void BroadcastToLogicServer::set_groupid(::google::protobuf::uint32 value) {
  set_has_groupid();
  groupid_ = value;
}

// required bytes msg = 2;
inline bool BroadcastToLogicServer::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadcastToLogicServer::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadcastToLogicServer::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadcastToLogicServer::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& BroadcastToLogicServer::msg() const {
  return *msg_;
}
inline void BroadcastToLogicServer::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void BroadcastToLogicServer::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void BroadcastToLogicServer::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastToLogicServer::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* BroadcastToLogicServer::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BroadcastToLogicServer::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogicToCenterCreateChar

// required uint32 charID = 1;
inline bool LogicToCenterCreateChar::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicToCenterCreateChar::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicToCenterCreateChar::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicToCenterCreateChar::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 LogicToCenterCreateChar::charid() const {
  return charid_;
}
inline void LogicToCenterCreateChar::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// required .ProtoBuf.CharacterDBBaseInfo base = 2;
inline bool LogicToCenterCreateChar::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicToCenterCreateChar::set_has_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicToCenterCreateChar::clear_has_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicToCenterCreateChar::clear_base() {
  if (base_ != NULL) base_->::ProtoBuf::CharacterDBBaseInfo::Clear();
  clear_has_base();
}
inline const ::ProtoBuf::CharacterDBBaseInfo& LogicToCenterCreateChar::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::ProtoBuf::CharacterDBBaseInfo* LogicToCenterCreateChar::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::ProtoBuf::CharacterDBBaseInfo;
  return base_;
}
inline ::ProtoBuf::CharacterDBBaseInfo* LogicToCenterCreateChar::release_base() {
  clear_has_base();
  ::ProtoBuf::CharacterDBBaseInfo* temp = base_;
  base_ = NULL;
  return temp;
}
inline void LogicToCenterCreateChar::set_allocated_base(::ProtoBuf::CharacterDBBaseInfo* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// -------------------------------------------------------------------

// LogicToCenterDelChar

// required uint32 charID = 1;
inline bool LogicToCenterDelChar::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicToCenterDelChar::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicToCenterDelChar::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicToCenterDelChar::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 LogicToCenterDelChar::charid() const {
  return charid_;
}
inline void LogicToCenterDelChar::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// required string channel_user_id = 2;
inline bool LogicToCenterDelChar::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicToCenterDelChar::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicToCenterDelChar::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicToCenterDelChar::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& LogicToCenterDelChar::channel_user_id() const {
  return *channel_user_id_;
}
inline void LogicToCenterDelChar::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LogicToCenterDelChar::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LogicToCenterDelChar::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicToCenterDelChar::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* LogicToCenterDelChar::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogicToCenterDelChar::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogicToCenterCharSync

// required uint32 charID = 1;
inline bool LogicToCenterCharSync::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicToCenterCharSync::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicToCenterCharSync::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicToCenterCharSync::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 LogicToCenterCharSync::charid() const {
  return charid_;
}
inline void LogicToCenterCharSync::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// repeated .ProtoBuf.CharSyncAttr attrlist = 2;
inline int LogicToCenterCharSync::attrlist_size() const {
  return attrlist_.size();
}
inline void LogicToCenterCharSync::clear_attrlist() {
  attrlist_.Clear();
}
inline const ::ProtoBuf::CharSyncAttr& LogicToCenterCharSync::attrlist(int index) const {
  return attrlist_.Get(index);
}
inline ::ProtoBuf::CharSyncAttr* LogicToCenterCharSync::mutable_attrlist(int index) {
  return attrlist_.Mutable(index);
}
inline ::ProtoBuf::CharSyncAttr* LogicToCenterCharSync::add_attrlist() {
  return attrlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::CharSyncAttr >&
LogicToCenterCharSync::attrlist() const {
  return attrlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::CharSyncAttr >*
LogicToCenterCharSync::mutable_attrlist() {
  return &attrlist_;
}

// repeated .ProtoBuf.ItemProtoInfo equip = 3;
inline int LogicToCenterCharSync::equip_size() const {
  return equip_.size();
}
inline void LogicToCenterCharSync::clear_equip() {
  equip_.Clear();
}
inline const ::ProtoBuf::ItemProtoInfo& LogicToCenterCharSync::equip(int index) const {
  return equip_.Get(index);
}
inline ::ProtoBuf::ItemProtoInfo* LogicToCenterCharSync::mutable_equip(int index) {
  return equip_.Mutable(index);
}
inline ::ProtoBuf::ItemProtoInfo* LogicToCenterCharSync::add_equip() {
  return equip_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::ItemProtoInfo >&
LogicToCenterCharSync::equip() const {
  return equip_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::ItemProtoInfo >*
LogicToCenterCharSync::mutable_equip() {
  return &equip_;
}

// optional int32 all_equip = 4;
inline bool LogicToCenterCharSync::has_all_equip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogicToCenterCharSync::set_has_all_equip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogicToCenterCharSync::clear_has_all_equip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogicToCenterCharSync::clear_all_equip() {
  all_equip_ = 0;
  clear_has_all_equip();
}
inline ::google::protobuf::int32 LogicToCenterCharSync::all_equip() const {
  return all_equip_;
}
inline void LogicToCenterCharSync::set_all_equip(::google::protobuf::int32 value) {
  set_has_all_equip();
  all_equip_ = value;
}

// -------------------------------------------------------------------

// EnterLogicRequest

// required uint32 character_id = 1;
inline bool EnterLogicRequest::has_character_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterLogicRequest::set_has_character_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterLogicRequest::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterLogicRequest::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 EnterLogicRequest::character_id() const {
  return character_id_;
}
inline void EnterLogicRequest::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
}

// required string channel_id = 2;
inline bool EnterLogicRequest::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterLogicRequest::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterLogicRequest::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterLogicRequest::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& EnterLogicRequest::channel_id() const {
  return *channel_id_;
}
inline void EnterLogicRequest::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void EnterLogicRequest::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void EnterLogicRequest::set_channel_id(const char* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterLogicRequest::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* EnterLogicRequest::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterLogicRequest::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user_id = 3;
inline bool EnterLogicRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterLogicRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterLogicRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterLogicRequest::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& EnterLogicRequest::user_id() const {
  return *user_id_;
}
inline void EnterLogicRequest::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void EnterLogicRequest::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void EnterLogicRequest::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterLogicRequest::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* EnterLogicRequest::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterLogicRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 token = 4;
inline bool EnterLogicRequest::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterLogicRequest::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterLogicRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterLogicRequest::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 EnterLogicRequest::token() const {
  return token_;
}
inline void EnterLogicRequest::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
}

// required string channel_user_id = 5;
inline bool EnterLogicRequest::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnterLogicRequest::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnterLogicRequest::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnterLogicRequest::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& EnterLogicRequest::channel_user_id() const {
  return *channel_user_id_;
}
inline void EnterLogicRequest::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void EnterLogicRequest::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void EnterLogicRequest::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterLogicRequest::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* EnterLogicRequest::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterLogicRequest::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ProtoBuf.CharacterDBSimpleInfo charSimpleInfo = 6;
inline bool EnterLogicRequest::has_charsimpleinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EnterLogicRequest::set_has_charsimpleinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EnterLogicRequest::clear_has_charsimpleinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EnterLogicRequest::clear_charsimpleinfo() {
  if (charsimpleinfo_ != NULL) charsimpleinfo_->::ProtoBuf::CharacterDBSimpleInfo::Clear();
  clear_has_charsimpleinfo();
}
inline const ::ProtoBuf::CharacterDBSimpleInfo& EnterLogicRequest::charsimpleinfo() const {
  return charsimpleinfo_ != NULL ? *charsimpleinfo_ : *default_instance_->charsimpleinfo_;
}
inline ::ProtoBuf::CharacterDBSimpleInfo* EnterLogicRequest::mutable_charsimpleinfo() {
  set_has_charsimpleinfo();
  if (charsimpleinfo_ == NULL) charsimpleinfo_ = new ::ProtoBuf::CharacterDBSimpleInfo;
  return charsimpleinfo_;
}
inline ::ProtoBuf::CharacterDBSimpleInfo* EnterLogicRequest::release_charsimpleinfo() {
  clear_has_charsimpleinfo();
  ::ProtoBuf::CharacterDBSimpleInfo* temp = charsimpleinfo_;
  charsimpleinfo_ = NULL;
  return temp;
}
inline void EnterLogicRequest::set_allocated_charsimpleinfo(::ProtoBuf::CharacterDBSimpleInfo* charsimpleinfo) {
  delete charsimpleinfo_;
  charsimpleinfo_ = charsimpleinfo;
  if (charsimpleinfo) {
    set_has_charsimpleinfo();
  } else {
    clear_has_charsimpleinfo();
  }
}

// optional int32 map_id = 7;
inline bool EnterLogicRequest::has_map_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EnterLogicRequest::set_has_map_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EnterLogicRequest::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EnterLogicRequest::clear_map_id() {
  map_id_ = 0;
  clear_has_map_id();
}
inline ::google::protobuf::int32 EnterLogicRequest::map_id() const {
  return map_id_;
}
inline void EnterLogicRequest::set_map_id(::google::protobuf::int32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional int32 scene_id = 8;
inline bool EnterLogicRequest::has_scene_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EnterLogicRequest::set_has_scene_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EnterLogicRequest::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EnterLogicRequest::clear_scene_id() {
  scene_id_ = 0;
  clear_has_scene_id();
}
inline ::google::protobuf::int32 EnterLogicRequest::scene_id() const {
  return scene_id_;
}
inline void EnterLogicRequest::set_scene_id(::google::protobuf::int32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// repeated .ProtoBuf.ItemProtoInfo equip = 9;
inline int EnterLogicRequest::equip_size() const {
  return equip_.size();
}
inline void EnterLogicRequest::clear_equip() {
  equip_.Clear();
}
inline const ::ProtoBuf::ItemProtoInfo& EnterLogicRequest::equip(int index) const {
  return equip_.Get(index);
}
inline ::ProtoBuf::ItemProtoInfo* EnterLogicRequest::mutable_equip(int index) {
  return equip_.Mutable(index);
}
inline ::ProtoBuf::ItemProtoInfo* EnterLogicRequest::add_equip() {
  return equip_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoBuf::ItemProtoInfo >&
EnterLogicRequest::equip() const {
  return equip_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoBuf::ItemProtoInfo >*
EnterLogicRequest::mutable_equip() {
  return &equip_;
}

// optional .ProtoBuf.CharacterDBAttrDetailInfo attr = 10;
inline bool EnterLogicRequest::has_attr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EnterLogicRequest::set_has_attr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EnterLogicRequest::clear_has_attr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EnterLogicRequest::clear_attr() {
  if (attr_ != NULL) attr_->::ProtoBuf::CharacterDBAttrDetailInfo::Clear();
  clear_has_attr();
}
inline const ::ProtoBuf::CharacterDBAttrDetailInfo& EnterLogicRequest::attr() const {
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
}
inline ::ProtoBuf::CharacterDBAttrDetailInfo* EnterLogicRequest::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) attr_ = new ::ProtoBuf::CharacterDBAttrDetailInfo;
  return attr_;
}
inline ::ProtoBuf::CharacterDBAttrDetailInfo* EnterLogicRequest::release_attr() {
  clear_has_attr();
  ::ProtoBuf::CharacterDBAttrDetailInfo* temp = attr_;
  attr_ = NULL;
  return temp;
}
inline void EnterLogicRequest::set_allocated_attr(::ProtoBuf::CharacterDBAttrDetailInfo* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
}

// -------------------------------------------------------------------

// LogoutLogicRequest

// required .ProtoBuf.LogoutLogicRequest.FLAG flag = 1;
inline bool LogoutLogicRequest::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutLogicRequest::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutLogicRequest::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutLogicRequest::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::ProtoBuf::LogoutLogicRequest_FLAG LogoutLogicRequest::flag() const {
  return static_cast< ::ProtoBuf::LogoutLogicRequest_FLAG >(flag_);
}
inline void LogoutLogicRequest::set_flag(::ProtoBuf::LogoutLogicRequest_FLAG value) {
  assert(::ProtoBuf::LogoutLogicRequest_FLAG_IsValid(value));
  set_has_flag();
  flag_ = value;
}

// required uint32 character_id = 2;
inline bool LogoutLogicRequest::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogoutLogicRequest::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogoutLogicRequest::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogoutLogicRequest::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 LogoutLogicRequest::character_id() const {
  return character_id_;
}
inline void LogoutLogicRequest::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
}

// required string channel_user_id = 3;
inline bool LogoutLogicRequest::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogoutLogicRequest::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogoutLogicRequest::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogoutLogicRequest::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& LogoutLogicRequest::channel_user_id() const {
  return *channel_user_id_;
}
inline void LogoutLogicRequest::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LogoutLogicRequest::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void LogoutLogicRequest::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogoutLogicRequest::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* LogoutLogicRequest::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogoutLogicRequest::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 token = 4;
inline bool LogoutLogicRequest::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogoutLogicRequest::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogoutLogicRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogoutLogicRequest::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 LogoutLogicRequest::token() const {
  return token_;
}
inline void LogoutLogicRequest::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
}

// -------------------------------------------------------------------

// AllocLogicNodeRequest

// required uint32 character_id = 1;
inline bool AllocLogicNodeRequest::has_character_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocLogicNodeRequest::set_has_character_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllocLogicNodeRequest::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllocLogicNodeRequest::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 AllocLogicNodeRequest::character_id() const {
  return character_id_;
}
inline void AllocLogicNodeRequest::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
}

// required string channel_id = 2;
inline bool AllocLogicNodeRequest::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocLogicNodeRequest::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllocLogicNodeRequest::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllocLogicNodeRequest::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& AllocLogicNodeRequest::channel_id() const {
  return *channel_id_;
}
inline void AllocLogicNodeRequest::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void AllocLogicNodeRequest::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void AllocLogicNodeRequest::set_channel_id(const char* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocLogicNodeRequest::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* AllocLogicNodeRequest::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllocLogicNodeRequest::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user_id = 3;
inline bool AllocLogicNodeRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AllocLogicNodeRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AllocLogicNodeRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AllocLogicNodeRequest::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& AllocLogicNodeRequest::user_id() const {
  return *user_id_;
}
inline void AllocLogicNodeRequest::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void AllocLogicNodeRequest::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void AllocLogicNodeRequest::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocLogicNodeRequest::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* AllocLogicNodeRequest::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllocLogicNodeRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string channel_user_id = 5;
inline bool AllocLogicNodeRequest::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AllocLogicNodeRequest::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AllocLogicNodeRequest::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AllocLogicNodeRequest::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& AllocLogicNodeRequest::channel_user_id() const {
  return *channel_user_id_;
}
inline void AllocLogicNodeRequest::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void AllocLogicNodeRequest::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void AllocLogicNodeRequest::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocLogicNodeRequest::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* AllocLogicNodeRequest::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllocLogicNodeRequest::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AllocLogicNodeResponse

// required int32 result = 1;
inline bool AllocLogicNodeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocLogicNodeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllocLogicNodeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllocLogicNodeResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AllocLogicNodeResponse::result() const {
  return result_;
}
inline void AllocLogicNodeResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required uint32 character_id = 2;
inline bool AllocLogicNodeResponse::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocLogicNodeResponse::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllocLogicNodeResponse::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllocLogicNodeResponse::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 AllocLogicNodeResponse::character_id() const {
  return character_id_;
}
inline void AllocLogicNodeResponse::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
}

// required string channel_id = 3;
inline bool AllocLogicNodeResponse::has_channel_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AllocLogicNodeResponse::set_has_channel_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AllocLogicNodeResponse::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AllocLogicNodeResponse::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& AllocLogicNodeResponse::channel_id() const {
  return *channel_id_;
}
inline void AllocLogicNodeResponse::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void AllocLogicNodeResponse::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void AllocLogicNodeResponse::set_channel_id(const char* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocLogicNodeResponse::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* AllocLogicNodeResponse::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllocLogicNodeResponse::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user_id = 4;
inline bool AllocLogicNodeResponse::has_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AllocLogicNodeResponse::set_has_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AllocLogicNodeResponse::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AllocLogicNodeResponse::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& AllocLogicNodeResponse::user_id() const {
  return *user_id_;
}
inline void AllocLogicNodeResponse::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void AllocLogicNodeResponse::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void AllocLogicNodeResponse::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocLogicNodeResponse::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* AllocLogicNodeResponse::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllocLogicNodeResponse::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string channel_user_id = 5;
inline bool AllocLogicNodeResponse::has_channel_user_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AllocLogicNodeResponse::set_has_channel_user_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AllocLogicNodeResponse::clear_has_channel_user_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AllocLogicNodeResponse::clear_channel_user_id() {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_user_id_->clear();
  }
  clear_has_channel_user_id();
}
inline const ::std::string& AllocLogicNodeResponse::channel_user_id() const {
  return *channel_user_id_;
}
inline void AllocLogicNodeResponse::set_channel_user_id(const ::std::string& value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void AllocLogicNodeResponse::set_channel_user_id(const char* value) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(value);
}
inline void AllocLogicNodeResponse::set_channel_user_id(const char* value, size_t size) {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  channel_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocLogicNodeResponse::mutable_channel_user_id() {
  set_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_user_id_ = new ::std::string;
  }
  return channel_user_id_;
}
inline ::std::string* AllocLogicNodeResponse::release_channel_user_id() {
  clear_has_channel_user_id();
  if (channel_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_user_id_;
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllocLogicNodeResponse::set_allocated_channel_user_id(::std::string* channel_user_id) {
  if (channel_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_user_id_;
  }
  if (channel_user_id) {
    set_has_channel_user_id();
    channel_user_id_ = channel_user_id;
  } else {
    clear_has_channel_user_id();
    channel_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 dst_scene_id = 6;
inline bool AllocLogicNodeResponse::has_dst_scene_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AllocLogicNodeResponse::set_has_dst_scene_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AllocLogicNodeResponse::clear_has_dst_scene_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AllocLogicNodeResponse::clear_dst_scene_id() {
  dst_scene_id_ = 0u;
  clear_has_dst_scene_id();
}
inline ::google::protobuf::uint32 AllocLogicNodeResponse::dst_scene_id() const {
  return dst_scene_id_;
}
inline void AllocLogicNodeResponse::set_dst_scene_id(::google::protobuf::uint32 value) {
  set_has_dst_scene_id();
  dst_scene_id_ = value;
}

// optional uint32 dst_map_id = 7;
inline bool AllocLogicNodeResponse::has_dst_map_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AllocLogicNodeResponse::set_has_dst_map_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AllocLogicNodeResponse::clear_has_dst_map_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AllocLogicNodeResponse::clear_dst_map_id() {
  dst_map_id_ = 0u;
  clear_has_dst_map_id();
}
inline ::google::protobuf::uint32 AllocLogicNodeResponse::dst_map_id() const {
  return dst_map_id_;
}
inline void AllocLogicNodeResponse::set_dst_map_id(::google::protobuf::uint32 value) {
  set_has_dst_map_id();
  dst_map_id_ = value;
}

// optional string logic_ip = 8;
inline bool AllocLogicNodeResponse::has_logic_ip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AllocLogicNodeResponse::set_has_logic_ip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AllocLogicNodeResponse::clear_has_logic_ip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AllocLogicNodeResponse::clear_logic_ip() {
  if (logic_ip_ != &::google::protobuf::internal::kEmptyString) {
    logic_ip_->clear();
  }
  clear_has_logic_ip();
}
inline const ::std::string& AllocLogicNodeResponse::logic_ip() const {
  return *logic_ip_;
}
inline void AllocLogicNodeResponse::set_logic_ip(const ::std::string& value) {
  set_has_logic_ip();
  if (logic_ip_ == &::google::protobuf::internal::kEmptyString) {
    logic_ip_ = new ::std::string;
  }
  logic_ip_->assign(value);
}
inline void AllocLogicNodeResponse::set_logic_ip(const char* value) {
  set_has_logic_ip();
  if (logic_ip_ == &::google::protobuf::internal::kEmptyString) {
    logic_ip_ = new ::std::string;
  }
  logic_ip_->assign(value);
}
inline void AllocLogicNodeResponse::set_logic_ip(const char* value, size_t size) {
  set_has_logic_ip();
  if (logic_ip_ == &::google::protobuf::internal::kEmptyString) {
    logic_ip_ = new ::std::string;
  }
  logic_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocLogicNodeResponse::mutable_logic_ip() {
  set_has_logic_ip();
  if (logic_ip_ == &::google::protobuf::internal::kEmptyString) {
    logic_ip_ = new ::std::string;
  }
  return logic_ip_;
}
inline ::std::string* AllocLogicNodeResponse::release_logic_ip() {
  clear_has_logic_ip();
  if (logic_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logic_ip_;
    logic_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllocLogicNodeResponse::set_allocated_logic_ip(::std::string* logic_ip) {
  if (logic_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete logic_ip_;
  }
  if (logic_ip) {
    set_has_logic_ip();
    logic_ip_ = logic_ip;
  } else {
    clear_has_logic_ip();
    logic_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 logic_port = 9;
inline bool AllocLogicNodeResponse::has_logic_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AllocLogicNodeResponse::set_has_logic_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AllocLogicNodeResponse::clear_has_logic_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AllocLogicNodeResponse::clear_logic_port() {
  logic_port_ = 0u;
  clear_has_logic_port();
}
inline ::google::protobuf::uint32 AllocLogicNodeResponse::logic_port() const {
  return logic_port_;
}
inline void AllocLogicNodeResponse::set_logic_port(::google::protobuf::uint32 value) {
  set_has_logic_port();
  logic_port_ = value;
}

// optional uint32 logic_token = 10;
inline bool AllocLogicNodeResponse::has_logic_token() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AllocLogicNodeResponse::set_has_logic_token() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AllocLogicNodeResponse::clear_has_logic_token() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AllocLogicNodeResponse::clear_logic_token() {
  logic_token_ = 0u;
  clear_has_logic_token();
}
inline ::google::protobuf::uint32 AllocLogicNodeResponse::logic_token() const {
  return logic_token_;
}
inline void AllocLogicNodeResponse::set_logic_token(::google::protobuf::uint32 value) {
  set_has_logic_token();
  logic_token_ = value;
}

// -------------------------------------------------------------------

// ClientNotifyToClient

// required uint32 charId = 1;
inline bool ClientNotifyToClient::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientNotifyToClient::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientNotifyToClient::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientNotifyToClient::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 ClientNotifyToClient::charid() const {
  return charid_;
}
inline void ClientNotifyToClient::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// required uint32 event = 2;
inline bool ClientNotifyToClient::has_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientNotifyToClient::set_has_event() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientNotifyToClient::clear_has_event() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientNotifyToClient::clear_event() {
  event_ = 0u;
  clear_has_event();
}
inline ::google::protobuf::uint32 ClientNotifyToClient::event() const {
  return event_;
}
inline void ClientNotifyToClient::set_event(::google::protobuf::uint32 value) {
  set_has_event();
  event_ = value;
}

// -------------------------------------------------------------------

// DBProxyAddrInfo

// required uint32 groupId = 1;
inline bool DBProxyAddrInfo::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBProxyAddrInfo::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBProxyAddrInfo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBProxyAddrInfo::clear_groupid() {
  groupid_ = 0u;
  clear_has_groupid();
}
inline ::google::protobuf::uint32 DBProxyAddrInfo::groupid() const {
  return groupid_;
}
inline void DBProxyAddrInfo::set_groupid(::google::protobuf::uint32 value) {
  set_has_groupid();
  groupid_ = value;
}

// required uint32 serverId = 2;
inline bool DBProxyAddrInfo::has_serverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBProxyAddrInfo::set_has_serverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBProxyAddrInfo::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBProxyAddrInfo::clear_serverid() {
  serverid_ = 0u;
  clear_has_serverid();
}
inline ::google::protobuf::uint32 DBProxyAddrInfo::serverid() const {
  return serverid_;
}
inline void DBProxyAddrInfo::set_serverid(::google::protobuf::uint32 value) {
  set_has_serverid();
  serverid_ = value;
}

// required uint32 Port = 3;
inline bool DBProxyAddrInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBProxyAddrInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBProxyAddrInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBProxyAddrInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 DBProxyAddrInfo::port() const {
  return port_;
}
inline void DBProxyAddrInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// required string Ip = 4;
inline bool DBProxyAddrInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBProxyAddrInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBProxyAddrInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBProxyAddrInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& DBProxyAddrInfo::ip() const {
  return *ip_;
}
inline void DBProxyAddrInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void DBProxyAddrInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void DBProxyAddrInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBProxyAddrInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* DBProxyAddrInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBProxyAddrInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CenterRspSceneId

// required uint32 retCode = 1;
inline bool CenterRspSceneId::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterRspSceneId::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterRspSceneId::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterRspSceneId::clear_retcode() {
  retcode_ = 0u;
  clear_has_retcode();
}
inline ::google::protobuf::uint32 CenterRspSceneId::retcode() const {
  return retcode_;
}
inline void CenterRspSceneId::set_retcode(::google::protobuf::uint32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional uint32 dstSceneId = 2;
inline bool CenterRspSceneId::has_dstsceneid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CenterRspSceneId::set_has_dstsceneid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CenterRspSceneId::clear_has_dstsceneid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CenterRspSceneId::clear_dstsceneid() {
  dstsceneid_ = 0u;
  clear_has_dstsceneid();
}
inline ::google::protobuf::uint32 CenterRspSceneId::dstsceneid() const {
  return dstsceneid_;
}
inline void CenterRspSceneId::set_dstsceneid(::google::protobuf::uint32 value) {
  set_has_dstsceneid();
  dstsceneid_ = value;
}

// optional .ProtoBuf.Vector3PB dstPos = 3;
inline bool CenterRspSceneId::has_dstpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CenterRspSceneId::set_has_dstpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CenterRspSceneId::clear_has_dstpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CenterRspSceneId::clear_dstpos() {
  if (dstpos_ != NULL) dstpos_->::ProtoBuf::Vector3PB::Clear();
  clear_has_dstpos();
}
inline const ::ProtoBuf::Vector3PB& CenterRspSceneId::dstpos() const {
  return dstpos_ != NULL ? *dstpos_ : *default_instance_->dstpos_;
}
inline ::ProtoBuf::Vector3PB* CenterRspSceneId::mutable_dstpos() {
  set_has_dstpos();
  if (dstpos_ == NULL) dstpos_ = new ::ProtoBuf::Vector3PB;
  return dstpos_;
}
inline ::ProtoBuf::Vector3PB* CenterRspSceneId::release_dstpos() {
  clear_has_dstpos();
  ::ProtoBuf::Vector3PB* temp = dstpos_;
  dstpos_ = NULL;
  return temp;
}
inline void CenterRspSceneId::set_allocated_dstpos(::ProtoBuf::Vector3PB* dstpos) {
  delete dstpos_;
  dstpos_ = dstpos;
  if (dstpos) {
    set_has_dstpos();
  } else {
    clear_has_dstpos();
  }
}

// optional string ip = 4;
inline bool CenterRspSceneId::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CenterRspSceneId::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CenterRspSceneId::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CenterRspSceneId::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& CenterRspSceneId::ip() const {
  return *ip_;
}
inline void CenterRspSceneId::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void CenterRspSceneId::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void CenterRspSceneId::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CenterRspSceneId::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* CenterRspSceneId::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CenterRspSceneId::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 5;
inline bool CenterRspSceneId::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CenterRspSceneId::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CenterRspSceneId::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CenterRspSceneId::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 CenterRspSceneId::port() const {
  return port_;
}
inline void CenterRspSceneId::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string token = 6;
inline bool CenterRspSceneId::has_token() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CenterRspSceneId::set_has_token() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CenterRspSceneId::clear_has_token() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CenterRspSceneId::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CenterRspSceneId::token() const {
  return *token_;
}
inline void CenterRspSceneId::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CenterRspSceneId::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CenterRspSceneId::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CenterRspSceneId::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CenterRspSceneId::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CenterRspSceneId::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 dstMapId = 7;
inline bool CenterRspSceneId::has_dstmapid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CenterRspSceneId::set_has_dstmapid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CenterRspSceneId::clear_has_dstmapid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CenterRspSceneId::clear_dstmapid() {
  dstmapid_ = 0u;
  clear_has_dstmapid();
}
inline ::google::protobuf::uint32 CenterRspSceneId::dstmapid() const {
  return dstmapid_;
}
inline void CenterRspSceneId::set_dstmapid(::google::protobuf::uint32 value) {
  set_has_dstmapid();
  dstmapid_ = value;
}

// -------------------------------------------------------------------

// CenterDailyUpdateNotify

// optional uint64 updateDailyTime = 1;
inline bool CenterDailyUpdateNotify::has_updatedailytime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterDailyUpdateNotify::set_has_updatedailytime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterDailyUpdateNotify::clear_has_updatedailytime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterDailyUpdateNotify::clear_updatedailytime() {
  updatedailytime_ = GOOGLE_ULONGLONG(0);
  clear_has_updatedailytime();
}
inline ::google::protobuf::uint64 CenterDailyUpdateNotify::updatedailytime() const {
  return updatedailytime_;
}
inline void CenterDailyUpdateNotify::set_updatedailytime(::google::protobuf::uint64 value) {
  set_has_updatedailytime();
  updatedailytime_ = value;
}

// -------------------------------------------------------------------

// CenterWeekUpdateNotify

// optional uint64 updateDailyTime = 1;
inline bool CenterWeekUpdateNotify::has_updatedailytime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterWeekUpdateNotify::set_has_updatedailytime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterWeekUpdateNotify::clear_has_updatedailytime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterWeekUpdateNotify::clear_updatedailytime() {
  updatedailytime_ = GOOGLE_ULONGLONG(0);
  clear_has_updatedailytime();
}
inline ::google::protobuf::uint64 CenterWeekUpdateNotify::updatedailytime() const {
  return updatedailytime_;
}
inline void CenterWeekUpdateNotify::set_updatedailytime(::google::protobuf::uint64 value) {
  set_has_updatedailytime();
  updatedailytime_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoBuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::LogicServerRegiste_TYPE>() {
  return ::ProtoBuf::LogicServerRegiste_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::CenterAccountLogoutNotify_TYPE>() {
  return ::ProtoBuf::CenterAccountLogoutNotify_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::LoginLogicResponse_RESULT>() {
  return ::ProtoBuf::LoginLogicResponse_RESULT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoBuf::LogoutLogicRequest_FLAG>() {
  return ::ProtoBuf::LogoutLogicRequest_FLAG_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoBuffer_2fServerInternalProtocol_2eproto__INCLUDED
